<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <link rel="icon" type="image/x-icon" href="public/favicon.ico" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="RSS Reader" />
  <link rel="apple-touch-icon" sizes="180x180" href="public/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="public/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="public/favicon-16x16.png" />
  <link rel="manifest" href="public/site.webmanifest" />
  <title>Feedic</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    // Configure Tailwind CSS for dark mode
    tailwind.config = {
      darkMode: 'class',
    }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/@mozilla/readability@0.5.0/Readability.js"></script>
  <!-- highlight.js for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

  <!-- Shoelace Web Components -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.1/cdn/themes/light.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.1/cdn/themes/dark.css" />
  <script type="module" src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.1/cdn/shoelace.js"></script>

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      box-sizing: border-box;
    }

    html,
    body {
      width: 100%;
      max-width: 100vw;
      overflow-x: hidden;
    }

    body {
      font-family: 'Inter', sans-serif;
      --sl-font-sans: 'Inter', sans-serif;
      word-break: break-word;
      word-wrap: break-word;
      overflow-wrap: anywhere;
    }

    .feed-item.active {
      background-color: var(--sl-color-primary-50);
    }

    .article-item.read {
      opacity: 0.6;
    }

    .loader {
      font-size: 2rem;
    }

    #detail-content h1,
    #detail-content h2,
    #detail-content h3 {
      font-size: 1.5em;
      font-weight: bold;
      margin-top: 1.2em;
      margin-bottom: 0.6em;
    }

    #detail-content p {
      margin-bottom: 1em;
      line-height: 1.6;
    }

    #detail-content a {
      color: var(--sl-color-primary-600);
      text-decoration: underline;
    }

    #detail-content img {
      max-width: 100%;
      height: auto;
      border-radius: 0.5rem;
      margin: 1em 0;
    }

    #detail-content ul,
    #detail-content ol {
      padding-left: 1.5em;
      margin-bottom: 1em;
      margin-top: 0.5em;
    }

    #detail-content ul {
      list-style-type: disc;
    }

    #detail-content ol {
      list-style-type: decimal;
    }

    #detail-content ul ul {
      list-style-type: circle;
      margin-top: 0.25em;
      margin-bottom: 0.25em;
    }

    #detail-content ol ol {
      list-style-type: lower-alpha;
      margin-top: 0.25em;
      margin-bottom: 0.25em;
    }

    #detail-content li {
      margin-bottom: 0.5em;
      line-height: 1.6;
      padding-left: 0.25em;
    }

    #detail-content li>p {
      margin-bottom: 0.5em;
    }

    #detail-content li:last-child {
      margin-bottom: 0;
    }

    /* Styling for code blocks */
    #detail-content pre {
      background-color: #282c34;
      color: #abb2bf;
      padding: 1.25em;
      border-radius: 0.5rem;
      overflow-x: auto;
      font-size: 0.9em;
    }

    #detail-content pre code.hljs {
      padding: 0;
    }

    /* Style for keyboard focus */
    .article-item:focus-visible {
      outline: 2px solid var(--sl-color-primary-600);
      outline-offset: 2px;
      box-shadow: 0 0 0 4px var(--sl-color-primary-200);
    }

    /* Resizable layout */
    .app-container {
      display: flex;
      height: 100vh;
      --sidebar-width: 25%;
    }

    #sidebar {
      width: var(--sidebar-width);
      min-width: 200px;
      max-width: 50%;
    }

    #resizer {
      width: 5px;
      cursor: col-resize;
      background-color: #e5e7eb;
      flex-shrink: 0;
    }

    .dark #resizer {
      background-color: #374151;
    }

    #resizer:hover {
      background-color: var(--sl-color-primary-200);
    }

    @media (max-width: 768px) {
      .app-container {
        --sidebar-width: 0px;
      }

      #resizer {
        display: none;
      }

      #sidebar {
        display: none;
      }

      #main-container {
        overflow-x: hidden;
      }

      body {
        overflow-x: hidden;
      }
    }


    @media (max-width: 400px) {
      .app-container {
        min-width: 0;
        width: 100%;
      }

      main {
        min-width: 0;
        width: 100%;
      }

      header {
        padding: 0.75rem;
      }

      .flex.items-center.space-x-3 {
        gap: 0.5rem;
      }

      .flex.items-center.space-x-2 {
        gap: 0.25rem;
      }

      #current-feed-title {
        max-width: 120px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      /* Mobile header layout optimizations for 360px */
      header .flex.items-center.justify-between.mb-4 {
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      header .flex.items-center.space-x-3 {
        flex: 1;
        min-width: 0;
      }

      header .flex.items-center.space-x-2 {
        flex-shrink: 0;
      }

      /* Second header row optimizations */
      header .flex.items-center.justify-between:last-child {
        gap: 0.5rem;
        align-items: center;
      }

      /* Tab group responsive sizing */
      #article-filter-tabs {
        flex: 1;
        min-width: 0;
      }

      #article-filter-tabs sl-tab {
        font-size: 0.875rem;
        padding: 0.25rem 0.5rem;
      }

      /* Read All button mobile optimization */
      #mark-all-read-btn {
        flex-shrink: 0;
        font-size: 1.25rem !important;
        width: 2rem;
        height: 2rem;
        min-width: 2rem;
      }

      /* Help button mobile sizing */
      #help-btn {
        font-size: 1rem !important;
        width: 1.75rem;
        height: 1.75rem;
        min-width: 1.75rem;
      }

      /* Theme dropdown button mobile sizing */
      sl-dropdown sl-icon-button {
        font-size: 1rem !important;
        width: 1.75rem;
        height: 1.75rem;
        min-width: 1.75rem;
      }

      /* Menu button mobile sizing */
      #menu-btn {
        font-size: 1.25rem !important;
        width: 2rem;
        height: 2rem;
        min-width: 2rem;
      }
    }

    /* Additional breakpoint for very narrow screens (360px and below) */
    @media (max-width: 360px) {
      header {
        padding: 0.5rem;
      }

      #current-feed-title {
        max-width: 100px;
      }

      /* Further compress tab text on very narrow screens */
      #article-filter-tabs sl-tab {
        font-size: 0.75rem;
        padding: 0.25rem 0.375rem;
      }

      /* Ensure Read All button remains visible */
      #mark-all-read-btn {
        font-size: 1.125rem !important;
        width: 1.875rem;
        height: 1.875rem;
        min-width: 1.875rem;
      }

      /* Compact other controls further */
      #help-btn, sl-dropdown sl-icon-button {
        font-size: 0.875rem !important;
        width: 1.5rem;
        height: 1.5rem;
        min-width: 1.5rem;
      }

      /* Reduce gaps further */
      header .flex.items-center.space-x-3 {
        gap: 0.375rem;
      }

      header .flex.items-center.space-x-2 {
        gap: 0.125rem;
      }

      header .flex.items-center.justify-between:last-child {
        gap: 0.375rem;
      }
    }
    

    /* Toast notification positioning */
    .sl-toast-stack {
      left: 50%;
      transform: translateX(-50%);
      right: auto;
      top: var(--sl-spacing-medium);
    }

    #global-loader {
      transition: opacity 0.3s ease-in-out;
    }

    sl-tab sl-badge {
      margin-left: var(--sl-spacing-x-small);
    }

    .article-item.new-article {
      border-left: 4px solid #ef4444;
    }

    /* 댓글 내용 스타일링 */
    .comment-content ul,
    .comment-content ol {
      padding-left: 1.5em;
      margin-bottom: 1em;
      margin-top: 0.5em;
    }

    .comment-content ul {
      list-style-type: disc;
    }

    .comment-content ol {
      list-style-type: decimal;
    }

    .comment-content ul ul {
      list-style-type: circle;
      margin-top: 0.25em;
      margin-bottom: 0.25em;
    }

    .comment-content ol ol {
      list-style-type: lower-alpha;
      margin-top: 0.25em;
      margin-bottom: 0.25em;
    }

    .comment-content li {
      margin-bottom: 0.5em;
      line-height: 1.6;
      padding-left: 0.25em;
    }

    .comment-content li>p {
      margin-bottom: 0.5em;
    }

    .comment-content li:last-child {
      margin-bottom: 0;
    }

    .comment-content a {
      color: var(--sl-color-primary-600);
      text-decoration: underline;
    }

    .comment-content code {
      background-color: #f3f4f6;
      color: #1f2937;
      padding: 0.125rem 0.25rem;
      border-radius: 0.25rem;
      font-size: 0.875em;
      font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
    }

    .dark .comment-content code {
      background-color: #374151;
      color: #e5e7eb;
    }

    .comment-content h6 {
      font-size: 1em;
      font-weight: 600;
      margin-bottom: 0.5em;
      margin-top: 1em;
    }

    .comment-content h6:first-child {
      margin-top: 0;
    }

    .comment-content p {
      margin-bottom: 0.75em;
      line-height: 1.6;
    }

    /* Text wrapping fixes for long content */
    #detail-content,
    #detail-content p,
    .article-item h3,
    .comment-content,
    #feed-list sl-menu-item span,
    #current-feed-title {
      word-break: break-word;
      word-wrap: break-word;
      overflow-wrap: anywhere;
    }

    /* Preserve code block formatting */
    #detail-content pre,
    #detail-content code,
    .comment-content pre,
    .comment-content code {
      word-break: normal;
      word-wrap: normal;
      overflow-wrap: normal;
      white-space: pre-wrap;
    }
  </style>
</head>

<body class="bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200 antialiased">

  <div id="global-loader" class="fixed inset-0 bg-white dark:bg-gray-900 z-[9999] flex items-center justify-center">
    <sl-spinner style="font-size: 3rem;"></sl-spinner>
  </div>

  <!-- Main App View -->
  <div id="main-container" class="relative min-h-screen">
    <div class="app-container">
      <!-- Sidebar -->
      <aside id="sidebar" class="bg-white dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700 flex flex-col">
        <div class="p-4 border-b dark:border-gray-700">
          <h1 class="text-xl font-bold text-gray-900 dark:text-gray-100">RSS 피드</h1>
        </div>
        <div class="p-4 border-b dark:border-gray-700">
          <form id="add-feed-form" class="flex flex-col space-y-3">
            <sl-textarea id="feed-urls" placeholder="여러 피드를 추가하려면 한 줄에 하나씩 URL을 입력하세요." resize="auto"></sl-textarea>
            <sl-button type="submit" variant="primary" class="w-full">피드 추가</sl-button>
          </form>
        </div>
        <nav id="feed-list" class="flex-1 overflow-y-auto p-2"></nav>
      </aside>

      <!-- Resizer -->
      <div id="resizer"></div>

      <!-- Main Content -->
      <main class="flex-1 flex flex-col bg-gray-50 dark:bg-gray-900 h-screen">
        <header class="p-4 border-b bg-white dark:bg-gray-800 dark:border-gray-700">
          <div class="flex items-center justify-between mb-4">
            <div class="flex items-center space-x-3">
              <sl-icon-button id="menu-btn" name="list" label="Menu" class="md:hidden text-2xl"></sl-icon-button>
              <div class="flex flex-col">
                <h2 id="current-feed-title" class="text-xl font-semibold truncate text-gray-900 dark:text-gray-100">모든
                  기사</h2>
                <span id="last-update-time" class="text-xs text-gray-500 dark:text-gray-400"></span>
              </div>
              <sl-icon-button id="help-btn" name="question-circle" label="Help" class="text-xl"></sl-icon-button>
            </div>
            <div class="flex items-center space-x-2">
              <sl-dropdown>
                <sl-icon-button name="sun" label="Theme" class="text-xl" slot="trigger"></sl-icon-button>
                <sl-menu id="theme-menu">
                  <sl-menu-item value="light">Light <sl-icon name="check" slot="suffix"></sl-icon></sl-menu-item>
                  <sl-menu-item value="dark">Dark <sl-icon name="check" slot="suffix"></sl-icon></sl-menu-item>
                  <sl-menu-item value="system">System <sl-icon name="check" slot="suffix"></sl-icon></sl-menu-item>
                </sl-menu>
              </sl-dropdown>
              <sl-spinner id="loader" class="loader hidden"></sl-spinner>
            </div>
          </div>
          <div class="flex items-center justify-between">
            <sl-tab-group id="article-filter-tabs">
              <sl-tab slot="nav" panel="unread" active>읽지 않음</sl-tab>
              <sl-tab slot="nav" panel="read">읽음</sl-tab>
              <sl-tab slot="nav" panel="all">모두</sl-tab>
            </sl-tab-group>
            <sl-icon-button id="mark-all-read-btn" name="check2-all" label="현재 목록 모두 읽음으로 표시"
              class="text-2xl"></sl-icon-button>
          </div>
        </header>
        <div id="article-list" class="flex-1 overflow-y-auto p-4 space-y-3">
          <div id="empty-state" class="text-center py-10 text-gray-500">
            <p>표시할 기사가 없습니다.</p>
          </div>
        </div>
      </main>
    </div>
  </div>

  <!-- Mobile Sidebar Drawer -->
  <sl-drawer id="mobile-sidebar-drawer" label="RSS 피드" class="md:hidden">
    <div id="mobile-sidebar-content" class="h-full flex flex-col"></div>
  </sl-drawer>

  <!-- Article Detail View -->
  <div id="article-detail-container" class="hidden fixed inset-0 bg-white dark:bg-gray-900 z-50 flex flex-col">
    <header
      class="flex items-center justify-between p-4 border-b dark:border-gray-700 sticky top-0 bg-white/80 dark:bg-gray-900/80 backdrop-blur-sm">
      <sl-icon-button id="detail-back-btn" name="arrow-left" label="Back" class="text-2xl"></sl-icon-button>
      <div class="flex items-center space-x-2">
        <sl-button id="detail-prev-btn" size="small"><sl-icon slot="prefix" name="arrow-left-short"></sl-icon>이전
          (←)</sl-button>
        <sl-button id="detail-next-btn" size="small"><sl-icon slot="suffix" name="arrow-right-short"></sl-icon>다음
          (→)</sl-button>
      </div>
      <sl-button id="detail-link-btn" href="#" target="_blank" variant="primary" size="small">원문 보기</sl-button>
    </header>
    <div id="detail-scroll-container" class="flex-1 overflow-y-auto p-6 md:p-8 lg:p-12">
      <div class="max-w-3xl mx-auto">
        <h1 id="detail-title" class="text-3xl md:text-4xl font-bold mb-2 text-gray-900 dark:text-gray-100"></h1>
        <p id="detail-author" class="text-gray-500 dark:text-gray-400 mb-8"></p>
        <div id="detail-content" class="prose dark:prose-invert lg:prose-xl max-w-none"></div>
      </div>
    </div>
  </div>

  <!-- Help Modal -->
  <sl-dialog id="help-modal" label="키보드 단축키">
    <ul class="space-y-4 text-gray-700 dark:text-gray-300">
      <li class="flex items-center"><kbd
          class="font-mono text-sm font-semibold text-gray-900 bg-gray-200 rounded-md px-2 py-1 mr-4">↑</kbd> / <kbd
          class="font-mono text-sm font-semibold text-gray-900 bg-gray-200 rounded-md px-2 py-1 mx-2">↓</kbd><span>기사
          목록에서 이동 / 상세 보기에서 스크롤</span></li>
      <li class="flex items-center"><kbd
          class="font-mono text-sm font-semibold text-gray-900 bg-gray-200 rounded-md px-2 py-1 mr-4">←</kbd> / <kbd
          class="font-mono text-sm font-semibold text-gray-900 bg-gray-200 rounded-md px-2 py-1 mx-2">→</kbd><span>상세
          보기에서 이전/다음 기사로 이동</span></li>
      <li class="flex items-center"><kbd
          class="font-mono text-sm font-semibold text-gray-900 bg-gray-200 rounded-md px-3 py-1 mr-4">Space</kbd><span>선택한
          기사 상세 보기</span></li>
      <li class="flex items-center"><kbd
          class="font-mono text-sm font-semibold text-gray-900 bg-gray-200 rounded-md px-2 py-1 mr-4">⌫</kbd><span>상세
          보기에서 목록으로 돌아가기 / 도움말 닫기</span></li>
    </ul>
    <sl-button slot="footer" variant="primary" onclick="document.getElementById('help-modal').hide()">닫기</sl-button>
  </sl-dialog>

  <script>
    const DB_NAME = 'RSSReaderDB', DB_VERSION = 1, FEED_STORE = 'feeds', ARTICLE_STORE = 'articles';
    let db;

    // DB, Feed, Article management functions (unchanged)
    function initDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = (e) => reject("Database error: " + e.target.errorCode);
        request.onsuccess = (e) => { db = e.target.result; resolve(db); };
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains(FEED_STORE)) db.createObjectStore(FEED_STORE, { keyPath: 'url' });
          if (!db.objectStoreNames.contains(ARTICLE_STORE)) {
            const store = db.createObjectStore(ARTICLE_STORE, { keyPath: 'guid' });
            store.createIndex('feedUrl', 'feedUrl', { unique: false });
            store.createIndex('pubDate', 'pubDate', { unique: false });
          }
        };
      });
    }
    const getAllFeeds = () => new Promise((resolve) => db.transaction([FEED_STORE]).objectStore(FEED_STORE).getAll().onsuccess = (e) => resolve(e.target.result));
    const deleteFeed = (url) => new Promise((resolve) => {
      const tx = db.transaction([FEED_STORE, ARTICLE_STORE], 'readwrite');
      tx.objectStore(FEED_STORE).delete(url);
      tx.objectStore(ARTICLE_STORE).index('feedUrl').openCursor(IDBKeyRange.only(url)).onsuccess = (e) => {
        const cursor = e.target.result; if (cursor) { cursor.delete(); cursor.continue(); }
      };
      tx.oncomplete = () => resolve();
    });
    async function saveArticles(articles) {
      if (!articles || articles.length === 0) return { hasNewArticles: false, newArticles: [] };
      let hasNewArticles = false;
      let newArticles = [];
      return new Promise((resolve) => {
        const tx = db.transaction([ARTICLE_STORE], 'readwrite');
        const store = tx.objectStore(ARTICLE_STORE);
        const guids = articles.map(a => a.guid);
        const existingArticles = new Map();
        store.openCursor().onsuccess = e => {
          const cursor = e.target.result;
          if (cursor) {
            if (guids.includes(cursor.key)) existingArticles.set(cursor.key, cursor.value);
            cursor.continue();
          } else {
            articles.forEach(newArticle => {
              const existing = existingArticles.get(newArticle.guid);
              if (!existing) {
                hasNewArticles = true;
                newArticles.push(newArticle);
              }
              store.put({ ...newArticle, read: existing ? existing.read : false });
            });
          }
        };
        tx.oncomplete = () => resolve({ hasNewArticles, newArticles });
      });
    }
    const getArticles = (feedUrl = null) => new Promise((resolve) => {
      const store = db.transaction([ARTICLE_STORE]).objectStore(ARTICLE_STORE);
      const req = feedUrl ? store.index('feedUrl').getAll(feedUrl) : store.getAll();
      req.onsuccess = () => resolve(req.result.sort((a, b) => new Date(b.pubDate) - new Date(a.pubDate)));
    });
    const getArticleByGuid = (guid) => new Promise((resolve) => db.transaction([ARTICLE_STORE]).objectStore(ARTICLE_STORE).get(guid).onsuccess = (e) => resolve(e.target.result));
    const setArticleReadStatus = (guid, read) => new Promise((resolve) => {
      const store = db.transaction([ARTICLE_STORE], 'readwrite').objectStore(ARTICLE_STORE);
      store.get(guid).onsuccess = e => {
        const article = e.target.result;
        if (article) { article.read = read; store.put(article).onsuccess = () => resolve(article.read); }
      };
    });

    function updateLastUpdateTime() {
      const lastUpdateEl = document.getElementById('last-update-time');
      if (lastUpdateTime) {
        const now = new Date();
        const diffMs = now - lastUpdateTime;
        const diffMins = Math.floor(diffMs / (1000 * 60));
        const diffHours = Math.floor(diffMs / (1000 * 60 * 60));

        let timeText = '';
        if (diffMins < 1) {
          timeText = '방금 업데이트';
        } else if (diffMins < 60) {
          timeText = `${diffMins}분 전 업데이트`;
        } else if (diffHours < 24) {
          timeText = `${diffHours}시간 전 업데이트`;
        } else {
          timeText = lastUpdateTime.toLocaleString('ko-KR', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' }) + ' 업데이트';
        }
        lastUpdateEl.textContent = timeText;
      }
    }

    // Update time display every minute
    setInterval(updateLastUpdateTime, 60000);

    // UI elements
    const feedListEl = document.getElementById('feed-list'), articleListEl = document.getElementById('article-list');
    const currentFeedTitleEl = document.getElementById('current-feed-title'), emptyStateEl = document.getElementById('empty-state');
    let currentFilter = null, articleFilter = 'unread', currentVisibleArticles = [], lastFocusedArticleGuid = null;
    let newArticleGuids = new Set();
    let lastUpdateTime = null;

    async function renderFeeds() {
      const feeds = await getAllFeeds();
      const feedListHTML = `
                <sl-menu>
                    <sl-menu-item data-url="all" class="${!currentFilter ? 'active' : ''}">모든 기사</sl-menu-item>
                    <sl-divider></sl-divider>
                    ${feeds.map(feed => `
                        <sl-menu-item data-url="${feed.url}" class="${currentFilter === feed.url ? 'active' : ''}">
                            <div class="w-full flex justify-between items-center">
                                <span class="truncate pr-2">${feed.title || feed.url}</span>
                                <sl-icon-button name="x-lg" label="Delete" class="delete-feed-btn text-lg" data-url="${feed.url}"></sl-icon-button>
                            </div>
                        </sl-menu-item>
                    `).join('')}
                </sl-menu>
            `;
      feedListEl.innerHTML = feedListHTML;
      document.getElementById('mobile-sidebar-content').innerHTML = document.querySelector('#sidebar').innerHTML;
    }

    // 댓글 개수를 빠르게 확인하는 함수 (캐시 지원)
    const commentCountCache = new Map();
    async function getCommentCount(url) {
      if (commentCountCache.has(url)) {
        return commentCountCache.get(url);
      }

      // news.hada.io나 clien.net만 지원
      if (!url.includes('news.hada.io') && !url.includes('clien.net')) {
        commentCountCache.set(url, 0);
        return 0;
      }

      try {
        const comments = await fetchComments(url);
        const count = comments ? comments.length : 0;
        commentCountCache.set(url, count);
        return count;
      } catch (error) {
        console.error('Error getting comment count:', error);
        commentCountCache.set(url, 0);
        return 0;
      }
    }

    async function renderArticles(feedUrl = null) {
      const allArticles = await getArticles(feedUrl);
      const feeds = await getAllFeeds();
      const feedsMap = new Map(feeds.map(f => [f.url, f]));

      // Update tab counts
      const unreadCount = allArticles.filter(a => !a.read).length;
      const readCount = allArticles.filter(a => a.read).length;
      document.querySelector('sl-tab[panel="unread"]').innerHTML = `읽지 않음 <sl-badge pill>${unreadCount}</sl-badge>`;
      document.querySelector('sl-tab[panel="read"]').innerHTML = `읽음 <sl-badge pill>${readCount}</sl-badge>`;
      document.querySelector('sl-tab[panel="all"]').innerHTML = `모두 <sl-badge pill>${allArticles.length}</sl-badge>`;

      if (articleFilter === 'unread') currentVisibleArticles = allArticles.filter(a => !a.read);
      else if (articleFilter === 'read') currentVisibleArticles = allArticles.filter(a => a.read);
      else currentVisibleArticles = allArticles;

      articleListEl.innerHTML = '';
      emptyStateEl.classList.toggle('hidden', currentVisibleArticles.length > 0);
      document.getElementById('mark-all-read-btn').style.display = (articleFilter !== 'read' && currentVisibleArticles.length > 0) ? 'block' : 'none';

      // 댓글 개수를 병렬로 가져오기 (성능 향상)
      const commentPromises = currentVisibleArticles.map(article =>
        getCommentCount(article.link)
      );
      const commentCounts = await Promise.all(commentPromises);

      currentVisibleArticles.forEach((article, index) => {
        const feed = feedsMap.get(article.feedUrl);
        const faviconUrl = feed ? feed.faviconUrl : '';
        const articleEl = document.createElement('div');
        const newArticleClass = newArticleGuids.has(article.guid) ? 'new-article' : '';
        articleEl.className = `article-item group bg-white dark:bg-gray-800 p-4 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 cursor-pointer ${article.read ? 'read' : ''} ${newArticleClass}`;
        articleEl.dataset.guid = article.guid;
        articleEl.setAttribute('tabindex', '0'); // Make focusable
        const pubDate = new Date(article.pubDate).toLocaleString('ko-KR');
        const commentCount = commentCounts[index];
        const commentBadge = commentCount > 0 ? `<sl-badge variant="neutral" pill class="ml-2">💬 ${commentCount}</sl-badge>` : '';

        articleEl.innerHTML = `
                    <div class="flex items-start space-x-4">
                        <img src="${faviconUrl}" onerror="this.src='https://placehold.co/32x32/e2e8f0/64748b?text=RSS'; this.onerror=null;" class="w-8 h-8 rounded-full bg-gray-200" alt="피드 아이콘">
                        <div class="flex-1">
                            <div class="flex items-center">
                                <h3 class="text-lg font-bold text-blue-800 dark:text-blue-400 group-hover:underline flex-1">${article.title}</h3>
                                ${commentBadge}
                            </div>
                            <p class="text-sm text-gray-500 dark:text-gray-400 mt-1">${article.author || '저자 없음'} &middot; ${pubDate}</p>
                        </div>
                        <sl-button variant="${article.read ? 'default' : 'primary'}" size="small" pill class="toggle-read-btn">${article.read ? '안 읽음' : '읽음'}</sl-button>
                    </div>`;
        articleListEl.appendChild(articleEl);
      });
    }

    // Feed parsing and syncing functions
    const loaderEl = document.getElementById('loader');
    async function fetchAndSaveFeed(feedUrl) {
      const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(feedUrl)}`;
      try {
        const response = await fetch(proxyUrl);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const xmlText = await response.text();

        const doc = new DOMParser().parseFromString(xmlText, 'application/xml');
        const parseError = doc.querySelector('parsererror');
        if (parseError) {
          console.error('XML Parsing Error:', parseError.textContent);
          throw new Error('유효하지 않은 RSS 피드 형식입니다.');
        }

        const feedTitle = doc.querySelector('channel > title')?.textContent || doc.querySelector('feed > title')?.textContent || 'Untitled Feed';
        const originalSiteLink = doc.querySelector('channel > link:not([rel])')?.textContent.trim() || doc.querySelector('feed > link[rel="alternate"]')?.getAttribute('href') || feedUrl;

        const items = Array.from(doc.querySelectorAll('item, entry'));
        const articles = items.map(item => {
          const title = item.querySelector('title')?.textContent || '[No Title]';
          const linkElement = item.querySelector('link');
          const link = linkElement?.getAttribute('href') || linkElement?.textContent.trim() || '';
          const guid = item.querySelector('guid')?.textContent || item.querySelector('id')?.textContent || link;
          const pubDate = item.querySelector('pubDate, published, updated')?.textContent || new Date().toISOString();
          const author = item.querySelector('author > name, creator')?.textContent || '';
          const content = item.querySelector('*|content, content')?.textContent || item.querySelector('description, summary')?.textContent || '';

          return { guid, title, link, author, pubDate: new Date(pubDate).toISOString(), content, feedUrl };
        });

        let faviconUrl = '';
        try {
          const domain = new URL(originalSiteLink).origin;
          faviconUrl = `https://www.google.com/s2/favicons?sz=32&domain_url=${domain}`;
        } catch (e) { console.warn("Could not determine domain for favicon for feed:", feedUrl); }

        await new Promise((resolve, reject) => {
          const tx = db.transaction([FEED_STORE], 'readwrite');
          const store = tx.objectStore(FEED_STORE);
          const feedData = { url: feedUrl, faviconUrl: faviconUrl, title: feedTitle };
          store.put(feedData);
          tx.oncomplete = () => resolve();
          tx.onerror = (e) => reject(e.target.error);
        });

        const result = await saveArticles(articles);
        const newArticles = result.newArticles || [];
        const newArticlesAdded = result.hasNewArticles || false;

        // Track new article GUIDs for visual separator
        newArticles.forEach(article => newArticleGuids.add(article.guid));

        return { feedTitle, newArticlesAdded, newArticleCount: newArticles.length };
      } catch (error) {
        console.error(`'${feedUrl}' 피드 가져오기 오류:`, error);
        throw error;
      }
    }
    async function refreshAllFeeds() {
      loaderEl.classList.remove('hidden');

      // Clear previous new article markers
      newArticleGuids.clear();

      const feeds = await getAllFeeds();
      const results = await Promise.allSettled(feeds.map(feed => fetchAndSaveFeed(feed.url)));

      let anyNewArticles = false;
      let totalNewArticles = 0;
      results.forEach(result => {
        if (result.status === 'fulfilled' && result.value.newArticlesAdded) {
          anyNewArticles = true;
          totalNewArticles += result.value.newArticleCount || 0;
        }
      });

      loaderEl.classList.add('hidden');
      await renderFeeds();
      await renderArticles(currentFilter);

      // Update last update time
      lastUpdateTime = new Date();
      updateLastUpdateTime();

      if (anyNewArticles) {
        showMessage(`새로운 기사 ${totalNewArticles}개를 가져왔습니다.`, 'success');
      }
    }

    // Event handlers and detail view logic
    const mainContainer = document.getElementById('main-container'), detailContainer = document.getElementById('article-detail-container');
    const showMessage = (message, type = 'error', duration = 3000) => {
      const alert = document.createElement('sl-alert');
      let variant = 'danger';
      let icon = 'exclamation-octagon';
      if (type === 'success') {
        variant = 'success';
        icon = 'check2-circle';
      } else if (type === 'info') {
        variant = 'primary';
        icon = 'info-circle';
      }
      alert.variant = variant;
      alert.duration = duration;
      alert.innerHTML = `<sl-icon name="${icon}" slot="icon"></sl-icon>${message}`;

      alert.addEventListener('click', () => alert.hide());

      document.body.appendChild(alert);
      alert.toast();
    };

    async function fetchComments(url) {
      // news.hada.io 댓글 가져오기
      if (url.includes('news.hada.io')) {
        try {
          const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
          const response = await fetch(proxyUrl);
          if (!response.ok) throw new Error('Network response was not ok.');
          const html = await response.text();

          const doc = new DOMParser().parseFromString(html, 'text/html');
          const comments = [];

          // news.hada.io의 댓글 구조 파싱
          let commentElements = [];

          const selectors = [
            'tr[id^="comment_tr_"]',
            '.comment_row',
            '[id^="cid"]',
            '#comment_thread .comment',
            '.comment',
            '[class*="comment"]'
          ];

          for (const selector of selectors) {
            commentElements = doc.querySelectorAll(selector);
            if (commentElements.length > 0) break;
          }

          commentElements.forEach((element, index) => {
            try {
              // 댓글 작성 폼이나 기타 UI 요소 제외
              if (element.querySelector('form.write_comment') ||
                element.querySelector('textarea') ||
                element.querySelector('input[type="submit"]') ||
                element.classList.contains('write_comment') ||
                element.innerHTML.includes('댓글 달기') ||
                element.innerHTML.includes('댓글 적기')) {
                return;
              }

              // 작성자 정보
              const authorSelectors = ['a[href*="/user?id="]', 'a[href*="/user"]', '.author', '.username'];
              let author = '익명';
              let hasValidAuthor = false;

              for (const selector of authorSelectors) {
                const authorEl = element.querySelector(selector);
                if (authorEl && authorEl.textContent.trim() && authorEl.textContent.trim() !== '익명') {
                  author = authorEl.textContent.trim();
                  hasValidAuthor = true;
                  break;
                }
              }

              // 시간 정보
              const timeSelectors = ['.comment_meta', '.meta', '.time', '.date'];
              let timeText = '';
              let hasValidTime = false;

              for (const selector of timeSelectors) {
                const timeEl = element.querySelector(selector);
                if (timeEl) {
                  const textNodes = Array.from(timeEl.childNodes).filter(node => node.nodeType === Node.TEXT_NODE);
                  timeText = textNodes.map(node => node.textContent.trim()).filter(text => text).join(' ');
                  if (timeText && (timeText.includes('전') || timeText.includes('시간') || timeText.includes('일'))) {
                    hasValidTime = true;
                    break;
                  }
                }
              }

              // 댓글 내용
              const contentSelectors = ['.comment_contents', '.contents', '.content', '.text', '.body'];
              let content = '';
              let htmlContent = '';
              let hasValidContent = false;

              for (const selector of contentSelectors) {
                const contentEl = element.querySelector(selector);
                if (contentEl) {
                  htmlContent = contentEl.innerHTML;
                  content = contentEl.textContent.trim();

                  // 폼 관련 내용이나 빈 내용 제외
                  if (content &&
                    !content.includes('댓글 달기') &&
                    !content.includes('댓글 적기') &&
                    !content.includes('인증 이메일') &&
                    content.length > 10) {
                    hasValidContent = true;
                    break;
                  }
                }
              }

              // 실제 댓글인지 검증 (작성자나 시간 정보가 있거나, 유효한 내용이 있는 경우만)
              if ((hasValidAuthor || hasValidTime || hasValidContent) &&
                content && content.length > 10) {
                const commentId = element.id || `comment_${index + 1}`;

                comments.push({
                  id: commentId,
                  author: author,
                  time: timeText,
                  content: content,
                  htmlContent: htmlContent
                });
              }
            } catch (error) {
              console.error(`Error parsing comment ${index}:`, error);
            }
          });
          return comments;
        } catch (error) {
          console.error('Error fetching comments:', error);
          return [];
        }
      }

      // clien.net 댓글 가져오기
      if (url.includes('clien.net')) {
        try {
          // URL에서 게시글 ID 추출
          const urlMatch = url.match(/\/([^\/]+)\/(\d+)$/);
          if (!urlMatch) {
            console.log('Could not extract board and post ID from URL:', url);
            return [];
          }

          const boardType = urlMatch[1]; // 'news'
          const postId = urlMatch[2]; // '19048102'

          console.log(`Clien.net: board=${boardType}, postId=${postId}`);

          // 먼저 일반 페이지 로드 시도
          const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
          const response = await fetch(proxyUrl);
          if (!response.ok) throw new Error('Network response was not ok.');
          const html = await response.text();

          const doc = new DOMParser().parseFromString(html, 'text/html');
          let comments = [];

          // clien.net의 댓글 구조 파싱 - 실제 구조 기반
          console.log('Clien.net comment parsing - using actual structure');

          // 댓글 컨테이너 찾기
          const commentContainer = doc.querySelector('.comment.ad_banner[data-role="comment"]');
          console.log('Comment container found:', !!commentContainer);

          if (!commentContainer) {
            // 다른 댓글 컨테이너 selector 시도
            const alternativeSelectors = ['.comment.ad_banner', '.comment', '#comment-head', '[class*="comment"]'];
            for (const selector of alternativeSelectors) {
              const altContainer = doc.querySelector(selector);
              if (altContainer) {
                console.log(`Found alternative comment container with selector: ${selector}`);
                console.log('Container HTML preview:', altContainer.innerHTML.substring(0, 200) + '...');
                break;
              }
            }
          }

          if (commentContainer) {
            // comment_row 요소들 찾기
            const commentRows = commentContainer.querySelectorAll('.comment_row[data-role="comment-row"]');
            console.log(`Found ${commentRows.length} comment rows`);

            // 댓글 컨테이너 내용 디버깅
            if (commentRows.length === 0) {
              console.log('Comment container HTML:', commentContainer.innerHTML.substring(0, 500) + '...');
              console.log('All children in comment container:', commentContainer.children.length);
              const allRows = commentContainer.querySelectorAll('.comment_row');
              console.log(`Found ${allRows.length} rows without data-role filter`);
              const allCommentDivs = commentContainer.querySelectorAll('div[class*="comment"]');
              console.log(`Found ${allCommentDivs.length} divs with comment in class`);
            }

            commentRows.forEach((row, index) => {
              try {
                // 데이터 속성에서 정보 추출
                const authorId = row.getAttribute('data-author-id');
                const commentSn = row.getAttribute('data-comment-sn');
                const isReply = row.classList.contains('re');

                console.log(`Processing comment row ${index + 1}: author=${authorId}, sn=${commentSn}, isReply=${isReply}`);

                // 닉네임 추출
                const nicknameEl = row.querySelector('.nickname');
                let author = authorId || '클리앙 사용자';
                if (nicknameEl && nicknameEl.textContent.trim()) {
                  author = nicknameEl.textContent.trim();
                }

                // 댓글 내용 추출
                const contentEl = row.querySelector('.comment_view');
                let content = '';
                let htmlContent = '';
                if (contentEl) {
                  content = contentEl.textContent.trim();
                  htmlContent = contentEl.innerHTML;
                } else {
                  // comment_view가 없으면 전체 텍스트에서 추출
                  const fullText = row.textContent.trim();
                  const lines = fullText.split('\n').filter(line => line.trim());
                  for (const line of lines) {
                    if (line.length > 5 &&
                      !line.includes('공감') &&
                      !line.includes('신고') &&
                      !line.includes('대댓글') &&
                      !line.match(/^\d+$/)) {
                      content = line;
                      break;
                    }
                  }
                }

                // 시간 정보 추출
                const timeEl = row.querySelector('.time, .date, [class*="time"], [class*="date"]');
                let timeText = '';
                if (timeEl) {
                  timeText = timeEl.textContent.trim();
                } else {
                  // 텍스트에서 시간 패턴 찾기
                  const fullText = row.textContent;
                  const timeMatch = fullText.match(/\d{2}-\d{2}-\d{2}\s+\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}/);
                  if (timeMatch) {
                    timeText = timeMatch[0];
                  }
                }

                // 유효한 댓글만 추가
                if (content && content.length > 1) {
                  comments.push({
                    id: commentSn || (index + 1),
                    author: author,
                    time: timeText,
                    content: content,
                    htmlContent: htmlContent || content,
                    isReply: isReply,
                    depth: isReply ? 1 : 0,
                    authorId: authorId
                  });
                  console.log(`Added ${isReply ? 'reply' : 'comment'} ${index + 1}: ${author} - ${content.substring(0, 30)}...`);
                } else {
                  console.log(`Skipped row ${index + 1} - no valid content`);
                }
              } catch (error) {
                console.error(`Error parsing comment row ${index}:`, error);
              }
            });
          }

          console.log(`Structure-based parsing found ${comments.length} comments`);

          // 구조 기반으로 찾지 못한 경우 텍스트 기반 파싱 사용 (개선됨)
          if (comments.length === 0) {
            console.log('Fallback to text-based parsing');
            console.log('Document body length:', doc.body.textContent.length);

            // 다양한 댓글 섹션 selector 시도
            const commentSectionSelectors = ['#comment-head', '#comments', '.comments', '[id*="comment"]'];
            let commentSection = null;

            for (const selector of commentSectionSelectors) {
              commentSection = doc.querySelector(selector);
              if (commentSection) {
                console.log(`Found comment section with selector: ${selector}`);
                break;
              }
            }

            // 전체 페이지에서 댓글 텍스트 찾기
            const textContent = commentSection ? commentSection.textContent : doc.body.textContent;
            const lines = textContent.split('\n').map(line => line.trim()).filter(line => line.length > 0);

            console.log(`Processing ${lines.length} text lines for comments`);

            // 댓글 ID 패턴이 있는지 먼저 확인
            const allText = textContent;
            const commentIdMatches = allText.match(/#\d{9,}/g);
            console.log(`Found ${commentIdMatches ? commentIdMatches.length : 0} comment ID patterns in text:`, commentIdMatches ? commentIdMatches.slice(0, 5) : 'none');

            // 텍스트 샘플 로그 (처음 10줄)
            console.log('First 10 lines of text:', lines.slice(0, 10));

            // 댓글 ID 패턴으로 모든 댓글 찾기 (대댓글 포함)
            let currentComment = null;
            let commentCount = 0;
            let collectingContent = false;

            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];

              // 댓글 ID 패턴 (#숫자 - 8자리 이상) 또는 대댓글 패턴
              const commentIdMatch = line.match(/^#\d{9,}$/) || line.match(/^Re:\s*#\d{9,}$/);
              if (commentIdMatch) {
                console.log(`Found comment ID pattern: ${line}`);
                if (currentComment && currentComment.content && currentComment.content.length > 5) {
                  comments.push(currentComment);
                  commentCount++;
                }
                const isReply = line.startsWith('Re:');
                currentComment = {
                  id: line,
                  author: '클리앙 사용자',
                  time: '',
                  content: '',
                  isReply: isReply,
                  depth: isReply ? 1 : 0
                };
                collectingContent = false;
                console.log(`Found ${isReply ? 'reply' : 'comment'} ID: ${line}`);
              }
              // 닉네임 패턴 (한글, 영문, 숫자, 특수문자 조합)
              else if (currentComment && !currentComment.authorSet && line.match(/^[가-힣a-zA-Z0-9_\-\[\]()]+$/)) {
                // IP나 날짜가 아닌 경우만 닉네임으로 처리
                if (!line.startsWith('IP') && !line.match(/\d{2}-\d{2}-\d{2}/) && line.length <= 20) {
                  currentComment.author = line;
                  currentComment.authorSet = true;
                  console.log(`Found author: ${line}`);
                }
              }
              // IP 주소 패턴
              else if (line.startsWith('IP ')) {
                if (currentComment) {
                  currentComment.ip = line;
                  // IP 이후부터 댓글 내용 수집 시작
                  collectingContent = true;
                }
              }
              // 날짜/시간 패턴
              else if (line.match(/\d{2}-\d{2}-\d{2}\s+\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}/)) {
                if (currentComment) {
                  currentComment.time = line;
                  collectingContent = true;
                }
              }
              // 액션 라인들 스킵
              else if (line.includes('대댓글') || line.includes('공감') || line.includes('신고') ||
                line === 'LINK' || line.match(/^\d+$/)) {
                continue;
              }
              // 실제 댓글 내용 수집 (여러 줄 지원)
              else if (currentComment && line.length > 3) {
                // 시스템 메시지나 UI 텍스트 제외하고 실제 댓글 내용 찾기
                if (!line.includes('대댓글') &&
                  !line.includes('공감') &&
                  !line.includes('신고') &&
                  !line.includes('등록') &&
                  !line.includes('수정') &&
                  !line.includes('삭제') &&
                  !line.includes('로그인') &&
                  !line.includes('새로고침') &&
                  !line.includes('목록') &&
                  !line.startsWith('IP ') &&
                  !line.match(/\d{2}-\d{2}-\d{2}/) &&
                  !line.match(/^\d+$/) &&
                  line !== 'LINK' &&
                  !line.match(/^(예|아니오|확인|취소|닫기)$/)) {

                  // 첫 번째 내용이거나 기존 내용에 추가
                  if (!currentComment.content) {
                    currentComment.content = line;
                    collectingContent = true;
                    console.log(`Found content start: ${line.substring(0, 50)}...`);
                  } else if (collectingContent) {
                    // 긴 댓글의 연속된 줄 추가
                    currentComment.content += '\n' + line;
                    console.log(`Added content line: ${line.substring(0, 30)}...`);
                  }
                }
              }
            }

            // 마지막 댓글 추가
            if (currentComment && currentComment.content && currentComment.content.length > 5) {
              comments.push(currentComment);
              commentCount++;
            }

            console.log(`Text-based parsing found ${commentCount} comments`);

            // 마지막으로 전체 HTML에서 댓글 패턴 직접 검색
            if (comments.length === 0) {
              console.log('Final attempt: searching entire HTML for comment patterns');
              const fullHtml = html;

              // 다양한 댓글 패턴 검색
              const patterns = [
                /#\d{9,}/g,  // 댓글 ID
                /data-comment-sn="(\d+)"/g,  // 댓글 시리얼 넘버
                /data-author-id="([^"]+)"/g,  // 작성자 ID
              ];

              patterns.forEach((pattern, index) => {
                const matches = fullHtml.match(pattern);
                console.log(`Pattern ${index + 1} matches:`, matches ? matches.length : 0, matches ? matches.slice(0, 3) : 'none');
              });

              // 댓글 관련 텍스트 직접 추출 시도
              const commentRegex = /IP\s+\d+\.\♡\.\d+\.\d+[\s\S]*?(?=#\d+|$)/g;
              const directMatches = fullHtml.match(commentRegex);
              if (directMatches && directMatches.length > 0) {
                console.log(`Found ${directMatches.length} direct comment patterns`);
                directMatches.forEach((match, index) => {
                  if (index < 3) {  // 처음 3개만 로그
                    console.log(`Direct match ${index + 1}:`, match.substring(0, 100) + '...');
                  }
                });
              }
            }
          }

          console.log(`Final result: ${comments.length} comments found`);

          return comments.map((comment, index) => ({
            id: comment.id || index + 1,
            author: comment.author || '클리앙 사용자',
            time: comment.time || '',
            content: comment.content || '',
            htmlContent: comment.htmlContent || comment.content,
            isReply: comment.isReply || false,
            depth: comment.depth || 0,
            authorId: comment.authorId
          }));
        } catch (error) {
          console.error('Error fetching clien.net comments:', error);
          return [];
        }
      }

      // 다른 사이트는 빈 배열 반환
      return [];
    }

    async function fetchAndDisplayFullContent(url, fallbackContent) {
      const detailContentEl = document.getElementById('detail-content');
      detailContentEl.innerHTML = '<div class="flex justify-center items-center p-8"><sl-spinner class="text-4xl"></sl-spinner></div>';
      try {
        const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
        const response = await fetch(proxyUrl);
        if (!response.ok) throw new Error('Network response was not ok.');
        const html = await response.text();

        const doc = new DOMParser().parseFromString(html, 'text/html');
        doc.baseURI = url;
        const reader = new Readability(doc);
        const article = reader.parse();

        if (article && article.content) {
          detailContentEl.innerHTML = article.content;
        } else {
          throw new Error('Readability could not parse the article.');
        }

        // 댓글 가져오기 및 표시
        console.log(`Fetching comments for URL: ${url}`);
        const comments = await fetchComments(url);
        console.log(`Fetched ${comments.length} comments:`, comments);
        if (comments.length > 0) {
          const commentsHtml = `
            <div id="comments-section" class="mt-12 pt-8 border-t dark:border-gray-700">
              <h3 class="text-xl font-bold mb-6 text-gray-900 dark:text-gray-100">댓글 ${comments.length}개</h3>
              <div class="space-y-4">
                ${comments.map(comment => `
                  <div class="${comment.isReply ? 'ml-8 border-l-2 border-blue-200 dark:border-blue-800' : ''} bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
                    <div class="flex items-center justify-between mb-2">
                      <div class="flex items-center">
                        ${comment.isReply ? '<span class="text-blue-500 mr-2">↳</span>' : ''}
                        <span class="font-semibold text-gray-900 dark:text-gray-100">${comment.author}</span>
                        ${comment.isReply ? '<span class="ml-2 text-xs bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200 px-2 py-1 rounded">답글</span>' : ''}
                      </div>
                      <span class="text-sm text-gray-500 dark:text-gray-400">${comment.time}</span>
                    </div>
                    <div class="comment-content text-gray-700 dark:text-gray-300">${comment.htmlContent || comment.content}</div>
                  </div>
                `).join('')}
              </div>
            </div>
          `;
          console.log(`Adding comments HTML to detail content`);
          detailContentEl.innerHTML += commentsHtml;
        } else {
          console.log(`No comments found for URL: ${url}`);
          // 댓글이 없는 경우에도 사용자에게 알림 표시
          if (url.includes('clien.net') || url.includes('news.hada.io')) {
            const noCommentsHtml = `
              <div id="comments-section" class="mt-12 pt-8 border-t dark:border-gray-700">
                <h3 class="text-xl font-bold mb-6 text-gray-900 dark:text-gray-100">댓글</h3>
                <div class="bg-gray-50 dark:bg-gray-800 rounded-lg p-4 text-center">
                  <p class="text-gray-600 dark:text-gray-400">
                    댓글을 불러오지 못했습니다. 
                    <a href="${url}" target="_blank" class="text-blue-600 dark:text-blue-400 hover:underline">
                      원본 페이지에서 확인하기
                    </a>
                  </p>
                </div>
              </div>
            `;
            detailContentEl.innerHTML += noCommentsHtml;
          }
        }

      } catch (error) {
        console.error('Error fetching full content:', error);
        detailContentEl.innerHTML = fallbackContent + '<p class="text-red-500 mt-4">전체 기사를 불러오는데 실패했습니다. 요약본을 표시합니다.</p>';
      } finally {
        detailContentEl.querySelectorAll('pre code').forEach((block) => {
          hljs.highlightElement(block);
        });
      }
    }

    async function updateDetailView(guid) {
      await setArticleReadStatus(guid, true);
      const article = await getArticleByGuid(guid);
      if (!article) return;
      document.getElementById('detail-title').textContent = article.title;
      document.getElementById('detail-author').textContent = `${article.author || '저자 없음'} · ${new Date(article.pubDate).toLocaleString('ko-KR')}`;
      document.getElementById('detail-link-btn').href = article.link;
      document.getElementById('detail-scroll-container').scrollTop = 0;

      const detailContentEl = document.getElementById('detail-content');
      const MIN_LENGTH_FOR_FULL_CONTENT = 1500;
      if (article.content && article.content.length > MIN_LENGTH_FOR_FULL_CONTENT) {
        detailContentEl.innerHTML = article.content;
        detailContentEl.querySelectorAll('pre code').forEach((block) => {
          hljs.highlightElement(block);
        });
      } else {
        fetchAndDisplayFullContent(article.link, article.content);
      }

      const currentIndex = currentVisibleArticles.findIndex(a => a.guid === guid);
      const prevBtn = document.getElementById('detail-prev-btn'), nextBtn = document.getElementById('detail-next-btn');
      prevBtn.disabled = currentIndex <= 0;
      nextBtn.disabled = currentIndex >= currentVisibleArticles.length - 1;
      prevBtn.dataset.guid = currentIndex > 0 ? currentVisibleArticles[currentIndex - 1].guid : '';
      nextBtn.dataset.guid = currentIndex < currentVisibleArticles.length - 1 ? currentVisibleArticles[currentIndex + 1].guid : '';
    }

    function showDetailView(guid, fromPopState = false) {
      lastFocusedArticleGuid = guid;
      mainContainer.classList.add('hidden');
      detailContainer.classList.remove('hidden');
      updateDetailView(guid);
      if (!fromPopState) {
        history.pushState({ guid: guid }, '', `#detail/${encodeURIComponent(guid)}`);
      }
    }

    function hideDetailView(fromPopState = false) {
      mainContainer.classList.remove('hidden');
      detailContainer.classList.add('hidden');
      renderArticles(currentFilter).then(() => {
        if (lastFocusedArticleGuid) {
          const lastFocusedEl = articleListEl.querySelector(`[data-guid="${lastFocusedArticleGuid}"]`);
          if (lastFocusedEl) {
            lastFocusedEl.focus();
          }
        }
      });
      if (!fromPopState) {
        history.pushState({}, '', window.location.pathname + window.location.search);
      }
    }

    // Use event delegation to handle form submission for both desktop and mobile
    document.body.addEventListener('submit', async (e) => {
      if (e.target.id !== 'add-feed-form') return;
      e.preventDefault();
      const urlsTextarea = e.target.querySelector('#feed-urls');
      const submitButton = e.target.querySelector('sl-button[type="submit"]');
      const urls = urlsTextarea.value.split('\n').map(url => url.trim()).filter(url => url && url.startsWith('http'));

      if (urls.length === 0) {
        showMessage('유효한 URL을 입력해주세요.', 'error');
        return;
      }

      // 버튼 로딩 상태 시작
      submitButton.loading = true;
      submitButton.disabled = true;
      loaderEl.classList.remove('hidden');

      const existingFeeds = await getAllFeeds();
      const existingUrls = new Set(existingFeeds.map(f => f.url));
      const newUrls = urls.filter(url => !existingUrls.has(url));

      if (newUrls.length === 0) {
        showMessage('입력된 모든 피드가 이미 추가되어 있습니다.', 'info');
        // 버튼 로딩 상태 종료
        submitButton.loading = false;
        submitButton.disabled = false;
        loaderEl.classList.add('hidden');
        urlsTextarea.value = '';
        return;
      }

      const results = await Promise.allSettled(newUrls.map(url => fetchAndSaveFeed(url)));

      let successfulCount = 0;
      let failedCount = 0;
      let totalNewArticlesFromFeeds = 0;
      results.forEach(result => {
        if (result.status === 'fulfilled') {
          successfulCount++;
          totalNewArticlesFromFeeds += result.value.newArticleCount || 0;
        }
        else {
          failedCount++;
          console.error('피드 추가 실패:', result.reason);
        }
      });

      urlsTextarea.value = '';
      await renderFeeds();
      await renderArticles(currentFilter);

      // 버튼 로딩 상태 종료
      submitButton.loading = false;
      submitButton.disabled = false;
      loaderEl.classList.add('hidden');

      let message = '';
      if (successfulCount > 0) {
        message += `${successfulCount}개의 피드를 추가했습니다.`;
        if (totalNewArticlesFromFeeds > 0) {
          message += ` (새 기사 ${totalNewArticlesFromFeeds}개)`;
        }
        message += ' ';
      }
      if (failedCount > 0) message += `${failedCount}개 추가에 실패했습니다.`;
      const messageType = successfulCount > 0 ? 'success' : 'error';
      showMessage(message.trim(), messageType);

      // Update last update time when adding feeds
      if (successfulCount > 0) {
        lastUpdateTime = new Date();
        updateLastUpdateTime();
      }
    });

    document.body.addEventListener('sl-select', async (e) => {
      const selectedItem = e.detail.item;
      if (selectedItem.closest('#feed-list') || selectedItem.closest('#mobile-sidebar-content')) {
        const url = selectedItem.dataset.url;
        currentFilter = (url === 'all') ? null : url;

        const feed = (await getAllFeeds()).find(f => f.url === url);
        currentFeedTitleEl.textContent = feed ? (feed.title || url) : '모든 기사';
        await renderFeeds();
        await renderArticles(currentFilter);

        const drawer = document.getElementById('mobile-sidebar-drawer');
        if (drawer.open) drawer.hide();
      }
    });

    document.body.addEventListener('click', async (e) => {
      const deleteBtn = e.target.closest('.delete-feed-btn');
      if (deleteBtn) {
        e.stopPropagation();
        const url = deleteBtn.dataset.url;
        if (confirm(`'${url}' 피드를 삭제하시겠습니까?`)) {
          await deleteFeed(url);
          if (currentFilter === url) { currentFilter = null; currentFeedTitleEl.textContent = '모든 기사'; }
          await renderFeeds(); await renderArticles(currentFilter);
        }
      }
    });

    articleListEl.addEventListener('click', async (e) => {
      const articleItem = e.target.closest('.article-item');
      if (!articleItem) return;
      const guid = articleItem.dataset.guid;
      if (e.target.closest('.toggle-read-btn')) {
        e.stopPropagation();
        const article = await getArticleByGuid(guid);
        await setArticleReadStatus(guid, !article.read);
        await renderArticles(currentFilter);
      } else {
        showDetailView(guid);
      }
    });
    articleListEl.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
        e.preventDefault();
        const items = Array.from(articleListEl.querySelectorAll('.article-item'));
        const currentItem = document.activeElement;
        const currentIndex = items.indexOf(currentItem);

        if (e.key === 'ArrowDown' && currentIndex < items.length - 1) {
          items[currentIndex + 1].focus();
        } else if (e.key === 'ArrowUp' && currentIndex > 0) {
          items[currentIndex - 1].focus();
        }
      } else if (e.key === ' ') {
        e.preventDefault();
        if (document.activeElement.classList.contains('article-item')) {
          document.activeElement.click();
        }
      }
    });

    // 키보드 이벤트를 여러 방법으로 처리
    function setupKeyboardHandlers() {
      const handlers = [
        { target: document, event: 'keydown' },
        { target: document, event: 'keypress' },
        { target: window, event: 'keydown' },
        { target: document.body, event: 'keydown' }
      ];

      const handleKey = (e) => {
        // 입력 필드에서 키 입력 시 무시
        if (e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) {
          return;
        }

        const helpModal = document.getElementById('help-modal');
        const detailContainer = document.getElementById('article-detail-container');
        const isDetailViewVisible = detailContainer && !detailContainer.classList.contains('hidden');

        console.log('Key pressed:', e.key, 'Detail view visible:', isDetailViewVisible); // 디버깅

        if (e.key === 'Backspace') {
          e.preventDefault();
          e.stopPropagation();
          if (helpModal && helpModal.open) {
            helpModal.hide();
          } else if (isDetailViewVisible) {
            hideDetailView();
          }
          return;
        }

        if (isDetailViewVisible) {
          if (e.key === 'ArrowRight') {
            document.getElementById('detail-next-btn').click();
          } else if (e.key === 'ArrowLeft') {
            document.getElementById('detail-prev-btn').click();
          } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
            e.preventDefault();
            const container = document.getElementById('detail-scroll-container');
            const scrollAmount = 120;
            if (e.key === 'ArrowDown') {
              container.scrollBy({ top: scrollAmount, behavior: 'smooth' });
            } else {
              container.scrollBy({ top: -scrollAmount, behavior: 'smooth' });
            }
          }
        }
      };

      handlers.forEach(({ target, event }) => {
        target.addEventListener(event, handleKey, { capture: true });
      });
    }

    // DOM 로드 후 핸들러 설정
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', setupKeyboardHandlers);
    } else {
      setupKeyboardHandlers();
    }

    document.getElementById('article-filter-tabs').addEventListener('sl-tab-show', (e) => {
      articleFilter = e.detail.name;
      renderArticles(currentFilter);
    });
    document.getElementById('detail-prev-btn').addEventListener('click', (e) => {
      if (!e.currentTarget.disabled) updateDetailView(e.currentTarget.dataset.guid);
    });
    document.getElementById('detail-next-btn').addEventListener('click', (e) => {
      if (!e.currentTarget.disabled) updateDetailView(e.currentTarget.dataset.guid);
    });
    document.getElementById('mark-all-read-btn').addEventListener('click', async () => {
      const articlesToUpdate = currentVisibleArticles.filter(a => !a.read);
      if (articlesToUpdate.length === 0) return;
      const tx = db.transaction([ARTICLE_STORE], 'readwrite');
      articlesToUpdate.forEach(article => { article.read = true; tx.objectStore(ARTICLE_STORE).put(article); });
      tx.oncomplete = async () => renderArticles(currentFilter);
    });

    document.getElementById('detail-back-btn').addEventListener('click', () => history.back());

    // Help Modal Logic
    document.getElementById('help-btn').addEventListener('click', () => document.getElementById('help-modal').show());

    // Mobile Menu Logic
    document.getElementById('menu-btn').addEventListener('click', () => document.getElementById('mobile-sidebar-drawer').show());

    // Resizer Logic
    const resizer = document.getElementById('resizer');
    const sidebar = document.getElementById('sidebar');
    resizer.addEventListener('mousedown', function (e) {
      e.preventDefault();
      document.body.style.cursor = 'col-resize';
      document.body.style.userSelect = 'none';

      let animationFrameId = null;
      function onMouseMove(e) {
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
        }
        animationFrameId = requestAnimationFrame(() => {
          const newWidth = e.clientX;
          const containerRect = sidebar.parentElement.getBoundingClientRect();
          const newRelativeWidth = (newWidth - containerRect.left) / containerRect.width * 100;
          document.documentElement.style.setProperty('--sidebar-width', `${newRelativeWidth}%`);
        });
      }

      function onMouseUp() {
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
        localStorage.setItem('sidebarWidth', document.documentElement.style.getPropertyValue('--sidebar-width'));
      }

      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });

    // Router Logic
    window.addEventListener('popstate', (event) => {
      const guid = event.state?.guid;
      if (guid) {
        showDetailView(guid, true);
      } else {
        hideDetailView(true);
      }
    });

    // Theme Logic
    const themeMenu = document.getElementById('theme-menu');
    const themeToggleButton = document.querySelector('sl-dropdown sl-icon-button');
    const html = document.documentElement;

    function applyTheme(theme) {
      const isDark = theme === 'dark' || (theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches);

      html.classList.toggle('dark', isDark);
      html.classList.toggle('sl-theme-dark', isDark);
      themeToggleButton.name = isDark ? 'moon-stars' : 'sun';

      themeMenu.querySelectorAll('sl-menu-item').forEach(item => {
        const checkIcon = item.querySelector('sl-icon[slot="suffix"]');
        checkIcon.style.visibility = item.value === theme ? 'visible' : 'hidden';
      });
    }

    themeMenu.addEventListener('sl-select', event => {
      const theme = event.detail.item.value;
      localStorage.setItem('rss-theme', theme);
      applyTheme(theme);
    });

    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
      const currentTheme = localStorage.getItem('rss-theme') || 'system';
      if (currentTheme === 'system') {
        applyTheme('system');
      }
    });

    // 7. 앱 시작
    window.addEventListener('load', async () => {
      const globalLoader = document.getElementById('global-loader');
      try {
        const savedWidth = localStorage.getItem('sidebarWidth');
        if (savedWidth) {
          document.documentElement.style.setProperty('--sidebar-width', savedWidth);
        }

        const savedTheme = localStorage.getItem('rss-theme') || 'system';
        applyTheme(savedTheme);

        await initDB();
        await renderFeeds();
        document.querySelector(`sl-tab[panel="${articleFilter}"]`).active = true;

        const initialHash = window.location.hash;
        if (initialHash.startsWith('#detail/')) {
          const guid = decodeURIComponent(initialHash.substring(8));
          await refreshAllFeeds();
          showDetailView(guid, true);
        } else {
          await renderArticles();
          await refreshAllFeeds();
        }
      } catch (error) {
        console.error("앱 초기화 실패:", error);
        document.body.innerHTML = '<div class="p-4 text-red-600">앱 초기화 실패. IndexedDB를 지원하는지 확인해주세요.</div>';
      } finally {
        globalLoader.style.opacity = '0';
        setTimeout(() => {
          globalLoader.style.display = 'none';
        }, 300);
      }
    });
  </script>
</body>

</html>