<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <link rel="icon" type="image/x-icon" href="public/favicon.ico" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="RSS Reader" />
  <link rel="apple-touch-icon" sizes="180x180" href="public/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="public/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="public/favicon-16x16.png" />
  <link rel="manifest" href="public/site.webmanifest" />
  <title>Feedic</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    // Configure Tailwind CSS for dark mode
    tailwind.config = {
      darkMode: 'class',
    }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/@mozilla/readability@0.5.0/Readability.js"></script>
  <!-- highlight.js for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

  <!-- Shoelace Web Components -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.1/cdn/themes/light.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.1/cdn/themes/dark.css" />
  <script type="module" src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.1/cdn/shoelace.js"></script>

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      box-sizing: border-box;
    }

    html,
    body {
      width: 100%;
      max-width: 100vw;
      overflow-x: hidden;
    }

    body {
      font-family: 'Inter', sans-serif;
      --sl-font-sans: 'Inter', sans-serif;
      word-break: break-word;
      word-wrap: break-word;
      overflow-wrap: anywhere;
    }

    .feed-item.active {
      background-color: var(--sl-color-primary-50);
    }

    .article-item.read {
      opacity: 0.6;
    }

    .loader {
      font-size: 2rem;
    }

    #detail-content h1,
    #detail-content h2,
    #detail-content h3 {
      font-size: 1.5em;
      font-weight: bold;
      margin-top: 1.2em;
      margin-bottom: 0.6em;
    }

    #detail-content p {
      margin-bottom: 1em;
      line-height: 1.6;
    }

    #detail-content a {
      color: var(--sl-color-primary-600);
      text-decoration: underline;
    }

    #detail-content img {
      max-width: 100%;
      height: auto;
      border-radius: 0.5rem;
      margin: 1em 0;
    }

    #detail-content ul,
    #detail-content ol {
      padding-left: 1.5em;
      margin-bottom: 1em;
      margin-top: 0.5em;
    }

    #detail-content ul {
      list-style-type: disc;
    }

    #detail-content ol {
      list-style-type: decimal;
    }

    #detail-content ul ul {
      list-style-type: circle;
      margin-top: 0.25em;
      margin-bottom: 0.25em;
    }

    #detail-content ol ol {
      list-style-type: lower-alpha;
      margin-top: 0.25em;
      margin-bottom: 0.25em;
    }

    #detail-content li {
      margin-bottom: 0.5em;
      line-height: 1.6;
      padding-left: 0.25em;
    }

    #detail-content li>p {
      margin-bottom: 0.5em;
    }

    #detail-content li:last-child {
      margin-bottom: 0;
    }

    /* Styling for code blocks */
    #detail-content pre {
      background-color: #282c34;
      color: #abb2bf;
      padding: 1.25em;
      border-radius: 0.5rem;
      overflow-x: auto;
      font-size: 0.9em;
    }

    #detail-content pre code.hljs {
      padding: 0;
    }

    /* Style for keyboard focus */
    .article-item:focus-visible {
      outline: 2px solid var(--sl-color-primary-600);
      outline-offset: 2px;
      box-shadow: 0 0 0 4px var(--sl-color-primary-200);
    }

    /* Resizable layout */
    .app-container {
      display: flex;
      height: 100vh;
      --sidebar-width: 25%;
    }

    #sidebar {
      width: var(--sidebar-width);
      min-width: 200px;
      max-width: 50%;
    }

    #resizer {
      width: 5px;
      cursor: col-resize;
      background-color: #e5e7eb;
      flex-shrink: 0;
    }

    .dark #resizer {
      background-color: #374151;
    }

    #resizer:hover {
      background-color: var(--sl-color-primary-200);
    }

    @media (max-width: 768px) {
      .app-container {
        --sidebar-width: 0px;
      }

      #resizer {
        display: none;
      }

      #sidebar {
        display: none;
      }

      #main-container {
        overflow-x: hidden;
      }

      body {
        overflow-x: hidden;
      }
    }


    @media (max-width: 400px) {
      .app-container {
        min-width: 0;
        width: 100%;
      }

      main {
        min-width: 0;
        width: 100%;
      }

      header {
        padding: 0.75rem;
      }

      .flex.items-center.space-x-3 {
        gap: 0.5rem;
      }

      .flex.items-center.space-x-2 {
        gap: 0.25rem;
      }

      #current-feed-title {
        max-width: 120px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      /* Mobile header layout optimizations for 360px */
      header .flex.items-center.justify-between.mb-4 {
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      header .flex.items-center.space-x-3 {
        flex: 1;
        min-width: 0;
      }

      header .flex.items-center.space-x-2 {
        flex-shrink: 0;
      }

      /* Second header row optimizations */
      header .flex.items-center.justify-between:last-child {
        gap: 0.5rem;
        align-items: center;
      }

      /* Tab group responsive sizing */
      #article-filter-tabs {
        flex: 1;
        min-width: 0;
      }

      #article-filter-tabs sl-tab {
        font-size: 0.875rem;
        padding: 0.25rem 0.5rem;
      }

      /* Read All button mobile optimization */
      #mark-all-read-btn {
        flex-shrink: 0;
        font-size: 1.25rem !important;
        width: 2rem;
        height: 2rem;
        min-width: 2rem;
      }

      /* Help button mobile sizing */
      #help-btn {
        font-size: 1rem !important;
        width: 1.75rem;
        height: 1.75rem;
        min-width: 1.75rem;
      }

      /* Theme dropdown button mobile sizing */
      sl-dropdown sl-icon-button {
        font-size: 1rem !important;
        width: 1.75rem;
        height: 1.75rem;
        min-width: 1.75rem;
      }

      /* Menu button mobile sizing */
      #menu-btn {
        font-size: 1.25rem !important;
        width: 2rem;
        height: 2rem;
        min-width: 2rem;
      }
    }

    /* Additional breakpoint for very narrow screens (360px and below) */
    @media (max-width: 360px) {
      header {
        padding: 0.5rem;
      }

      #current-feed-title {
        max-width: 100px;
      }

      /* Further compress tab text on very narrow screens */
      #article-filter-tabs sl-tab {
        font-size: 0.75rem;
        padding: 0.25rem 0.375rem;
      }

      /* Ensure Read All button remains visible */
      #mark-all-read-btn {
        font-size: 1.125rem !important;
        width: 1.875rem;
        height: 1.875rem;
        min-width: 1.875rem;
      }

      /* Compact other controls further */
      #help-btn, sl-dropdown sl-icon-button {
        font-size: 0.875rem !important;
        width: 1.5rem;
        height: 1.5rem;
        min-width: 1.5rem;
      }

      /* Reduce gaps further */
      header .flex.items-center.space-x-3 {
        gap: 0.375rem;
      }

      header .flex.items-center.space-x-2 {
        gap: 0.125rem;
      }

      header .flex.items-center.justify-between:last-child {
        gap: 0.375rem;
      }
    }
    

    /* Toast notification positioning */
    .sl-toast-stack {
      left: 50%;
      transform: translateX(-50%);
      right: auto;
      top: var(--sl-spacing-medium);
    }

    #global-loader {
      transition: opacity 0.3s ease-in-out;
    }

    sl-tab sl-badge {
      margin-left: var(--sl-spacing-x-small);
    }

    .article-item.new-article {
      border-left: 4px solid #ef4444;
    }

    /* ëŒ“ê¸€ ë‚´ìš© ìŠ¤íƒ€ì¼ë§ */
    .comment-content ul,
    .comment-content ol {
      padding-left: 1.5em;
      margin-bottom: 1em;
      margin-top: 0.5em;
    }

    .comment-content ul {
      list-style-type: disc;
    }

    .comment-content ol {
      list-style-type: decimal;
    }

    .comment-content ul ul {
      list-style-type: circle;
      margin-top: 0.25em;
      margin-bottom: 0.25em;
    }

    .comment-content ol ol {
      list-style-type: lower-alpha;
      margin-top: 0.25em;
      margin-bottom: 0.25em;
    }

    .comment-content li {
      margin-bottom: 0.5em;
      line-height: 1.6;
      padding-left: 0.25em;
    }

    .comment-content li>p {
      margin-bottom: 0.5em;
    }

    .comment-content li:last-child {
      margin-bottom: 0;
    }

    .comment-content a {
      color: var(--sl-color-primary-600);
      text-decoration: underline;
    }

    .comment-content code {
      background-color: #f3f4f6;
      color: #1f2937;
      padding: 0.125rem 0.25rem;
      border-radius: 0.25rem;
      font-size: 0.875em;
      font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
    }

    .dark .comment-content code {
      background-color: #374151;
      color: #e5e7eb;
    }

    .comment-content h6 {
      font-size: 1em;
      font-weight: 600;
      margin-bottom: 0.5em;
      margin-top: 1em;
    }

    .comment-content h6:first-child {
      margin-top: 0;
    }

    .comment-content p {
      margin-bottom: 0.75em;
      line-height: 1.6;
    }

    /* Text wrapping fixes for long content */
    #detail-content,
    #detail-content p,
    .article-item h3,
    .comment-content,
    #feed-list sl-menu-item span,
    #current-feed-title {
      word-break: break-word;
      word-wrap: break-word;
      overflow-wrap: anywhere;
    }

    /* Preserve code block formatting */
    #detail-content pre,
    #detail-content code,
    .comment-content pre,
    .comment-content code {
      word-break: normal;
      word-wrap: normal;
      overflow-wrap: normal;
      white-space: pre-wrap;
    }
  </style>
</head>

<body class="bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200 antialiased">

  <div id="global-loader" class="fixed inset-0 bg-white dark:bg-gray-900 z-[9999] flex items-center justify-center">
    <sl-spinner style="font-size: 3rem;"></sl-spinner>
  </div>

  <!-- Main App View -->
  <div id="main-container" class="relative min-h-screen">
    <div class="app-container">
      <!-- Sidebar -->
      <aside id="sidebar" class="bg-white dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700 flex flex-col">
        <div class="p-4 border-b dark:border-gray-700">
          <h1 class="text-xl font-bold text-gray-900 dark:text-gray-100">RSS í”¼ë“œ</h1>
        </div>
        <div class="p-4 border-b dark:border-gray-700">
          <form id="add-feed-form" class="flex flex-col space-y-3">
            <sl-textarea id="feed-urls" placeholder="ì—¬ëŸ¬ í”¼ë“œë¥¼ ì¶”ê°€í•˜ë ¤ë©´ í•œ ì¤„ì— í•˜ë‚˜ì”© URLì„ ì…ë ¥í•˜ì„¸ìš”." resize="auto"></sl-textarea>
            <sl-button type="submit" variant="primary" class="w-full">í”¼ë“œ ì¶”ê°€</sl-button>
          </form>
        </div>
        <nav id="feed-list" class="flex-1 overflow-y-auto p-2"></nav>
      </aside>

      <!-- Resizer -->
      <div id="resizer"></div>

      <!-- Main Content -->
      <main class="flex-1 flex flex-col bg-gray-50 dark:bg-gray-900 h-screen">
        <header class="p-4 border-b bg-white dark:bg-gray-800 dark:border-gray-700">
          <div class="flex items-center justify-between mb-4">
            <div class="flex items-center space-x-3">
              <sl-icon-button id="menu-btn" name="list" label="Menu" class="md:hidden text-2xl"></sl-icon-button>
              <div class="flex flex-col">
                <h2 id="current-feed-title" class="text-xl font-semibold truncate text-gray-900 dark:text-gray-100">ëª¨ë“ 
                  ê¸°ì‚¬</h2>
                <span id="last-update-time" class="text-xs text-gray-500 dark:text-gray-400"></span>
              </div>
              <sl-icon-button id="help-btn" name="question-circle" label="Help" class="text-xl"></sl-icon-button>
            </div>
            <div class="flex items-center space-x-2">
              <sl-dropdown>
                <sl-icon-button name="sun" label="Theme" class="text-xl" slot="trigger"></sl-icon-button>
                <sl-menu id="theme-menu">
                  <sl-menu-item value="light">Light <sl-icon name="check" slot="suffix"></sl-icon></sl-menu-item>
                  <sl-menu-item value="dark">Dark <sl-icon name="check" slot="suffix"></sl-icon></sl-menu-item>
                  <sl-menu-item value="system">System <sl-icon name="check" slot="suffix"></sl-icon></sl-menu-item>
                </sl-menu>
              </sl-dropdown>
              <sl-spinner id="loader" class="loader hidden"></sl-spinner>
            </div>
          </div>
          <div class="flex items-center justify-between">
            <sl-tab-group id="article-filter-tabs">
              <sl-tab slot="nav" panel="unread" active>ì½ì§€ ì•ŠìŒ</sl-tab>
              <sl-tab slot="nav" panel="read">ì½ìŒ</sl-tab>
              <sl-tab slot="nav" panel="all">ëª¨ë‘</sl-tab>
            </sl-tab-group>
            <sl-icon-button id="mark-all-read-btn" name="check2-all" label="í˜„ì¬ ëª©ë¡ ëª¨ë‘ ì½ìŒìœ¼ë¡œ í‘œì‹œ"
              class="text-2xl"></sl-icon-button>
          </div>
        </header>
        <div id="article-list" class="flex-1 overflow-y-auto p-4 space-y-3">
          <div id="empty-state" class="text-center py-10 text-gray-500">
            <p>í‘œì‹œí•  ê¸°ì‚¬ê°€ ì—†ìŠµë‹ˆë‹¤.</p>
          </div>
        </div>
      </main>
    </div>
  </div>

  <!-- Mobile Sidebar Drawer -->
  <sl-drawer id="mobile-sidebar-drawer" label="RSS í”¼ë“œ" class="md:hidden">
    <div id="mobile-sidebar-content" class="h-full flex flex-col"></div>
  </sl-drawer>

  <!-- Article Detail View -->
  <div id="article-detail-container" class="hidden fixed inset-0 bg-white dark:bg-gray-900 z-50 flex flex-col">
    <header
      class="flex items-center justify-between p-4 border-b dark:border-gray-700 sticky top-0 bg-white/80 dark:bg-gray-900/80 backdrop-blur-sm">
      <sl-icon-button id="detail-back-btn" name="arrow-left" label="Back" class="text-2xl"></sl-icon-button>
      <div class="flex items-center space-x-2">
        <sl-button id="detail-prev-btn" size="small"><sl-icon slot="prefix" name="arrow-left-short"></sl-icon>ì´ì „
          (â†)</sl-button>
        <sl-button id="detail-next-btn" size="small"><sl-icon slot="suffix" name="arrow-right-short"></sl-icon>ë‹¤ìŒ
          (â†’)</sl-button>
      </div>
      <sl-button id="detail-link-btn" href="#" target="_blank" variant="primary" size="small">ì›ë¬¸ ë³´ê¸°</sl-button>
    </header>
    <div id="detail-scroll-container" class="flex-1 overflow-y-auto p-6 md:p-8 lg:p-12">
      <div class="max-w-3xl mx-auto">
        <h1 id="detail-title" class="text-3xl md:text-4xl font-bold mb-2 text-gray-900 dark:text-gray-100"></h1>
        <p id="detail-author" class="text-gray-500 dark:text-gray-400 mb-8"></p>
        <div id="detail-content" class="prose dark:prose-invert lg:prose-xl max-w-none"></div>
      </div>
    </div>
  </div>

  <!-- Help Modal -->
  <sl-dialog id="help-modal" label="í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤">
    <ul class="space-y-4 text-gray-700 dark:text-gray-300">
      <li class="flex items-center"><kbd
          class="font-mono text-sm font-semibold text-gray-900 bg-gray-200 rounded-md px-2 py-1 mr-4">â†‘</kbd> / <kbd
          class="font-mono text-sm font-semibold text-gray-900 bg-gray-200 rounded-md px-2 py-1 mx-2">â†“</kbd><span>ê¸°ì‚¬
          ëª©ë¡ì—ì„œ ì´ë™ / ìƒì„¸ ë³´ê¸°ì—ì„œ ìŠ¤í¬ë¡¤</span></li>
      <li class="flex items-center"><kbd
          class="font-mono text-sm font-semibold text-gray-900 bg-gray-200 rounded-md px-2 py-1 mr-4">â†</kbd> / <kbd
          class="font-mono text-sm font-semibold text-gray-900 bg-gray-200 rounded-md px-2 py-1 mx-2">â†’</kbd><span>ìƒì„¸
          ë³´ê¸°ì—ì„œ ì´ì „/ë‹¤ìŒ ê¸°ì‚¬ë¡œ ì´ë™</span></li>
      <li class="flex items-center"><kbd
          class="font-mono text-sm font-semibold text-gray-900 bg-gray-200 rounded-md px-3 py-1 mr-4">Space</kbd><span>ì„ íƒí•œ
          ê¸°ì‚¬ ìƒì„¸ ë³´ê¸°</span></li>
      <li class="flex items-center"><kbd
          class="font-mono text-sm font-semibold text-gray-900 bg-gray-200 rounded-md px-2 py-1 mr-4">âŒ«</kbd><span>ìƒì„¸
          ë³´ê¸°ì—ì„œ ëª©ë¡ìœ¼ë¡œ ëŒì•„ê°€ê¸° / ë„ì›€ë§ ë‹«ê¸°</span></li>
    </ul>
    <sl-button slot="footer" variant="primary" onclick="document.getElementById('help-modal').hide()">ë‹«ê¸°</sl-button>
  </sl-dialog>

  <script>
    const DB_NAME = 'RSSReaderDB', DB_VERSION = 1, FEED_STORE = 'feeds', ARTICLE_STORE = 'articles';
    let db;

    // DB, Feed, Article management functions (unchanged)
    function initDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = (e) => reject("Database error: " + e.target.errorCode);
        request.onsuccess = (e) => { db = e.target.result; resolve(db); };
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains(FEED_STORE)) db.createObjectStore(FEED_STORE, { keyPath: 'url' });
          if (!db.objectStoreNames.contains(ARTICLE_STORE)) {
            const store = db.createObjectStore(ARTICLE_STORE, { keyPath: 'guid' });
            store.createIndex('feedUrl', 'feedUrl', { unique: false });
            store.createIndex('pubDate', 'pubDate', { unique: false });
          }
        };
      });
    }
    const getAllFeeds = () => new Promise((resolve) => db.transaction([FEED_STORE]).objectStore(FEED_STORE).getAll().onsuccess = (e) => resolve(e.target.result));
    const deleteFeed = (url) => new Promise((resolve) => {
      const tx = db.transaction([FEED_STORE, ARTICLE_STORE], 'readwrite');
      tx.objectStore(FEED_STORE).delete(url);
      tx.objectStore(ARTICLE_STORE).index('feedUrl').openCursor(IDBKeyRange.only(url)).onsuccess = (e) => {
        const cursor = e.target.result; if (cursor) { cursor.delete(); cursor.continue(); }
      };
      tx.oncomplete = () => resolve();
    });
    async function saveArticles(articles) {
      if (!articles || articles.length === 0) return { hasNewArticles: false, newArticles: [] };
      let hasNewArticles = false;
      let newArticles = [];
      return new Promise((resolve) => {
        const tx = db.transaction([ARTICLE_STORE], 'readwrite');
        const store = tx.objectStore(ARTICLE_STORE);
        const guids = articles.map(a => a.guid);
        const existingArticles = new Map();
        store.openCursor().onsuccess = e => {
          const cursor = e.target.result;
          if (cursor) {
            if (guids.includes(cursor.key)) existingArticles.set(cursor.key, cursor.value);
            cursor.continue();
          } else {
            articles.forEach(newArticle => {
              const existing = existingArticles.get(newArticle.guid);
              if (!existing) {
                hasNewArticles = true;
                newArticles.push(newArticle);
              }
              store.put({ ...newArticle, read: existing ? existing.read : false });
            });
          }
        };
        tx.oncomplete = () => resolve({ hasNewArticles, newArticles });
      });
    }
    const getArticles = (feedUrl = null) => new Promise((resolve) => {
      const store = db.transaction([ARTICLE_STORE]).objectStore(ARTICLE_STORE);
      const req = feedUrl ? store.index('feedUrl').getAll(feedUrl) : store.getAll();
      req.onsuccess = () => resolve(req.result.sort((a, b) => new Date(b.pubDate) - new Date(a.pubDate)));
    });
    const getArticleByGuid = (guid) => new Promise((resolve) => db.transaction([ARTICLE_STORE]).objectStore(ARTICLE_STORE).get(guid).onsuccess = (e) => resolve(e.target.result));
    const setArticleReadStatus = (guid, read) => new Promise((resolve) => {
      const store = db.transaction([ARTICLE_STORE], 'readwrite').objectStore(ARTICLE_STORE);
      store.get(guid).onsuccess = e => {
        const article = e.target.result;
        if (article) { article.read = read; store.put(article).onsuccess = () => resolve(article.read); }
      };
    });

    function updateLastUpdateTime() {
      const lastUpdateEl = document.getElementById('last-update-time');
      if (lastUpdateTime) {
        const now = new Date();
        const diffMs = now - lastUpdateTime;
        const diffMins = Math.floor(diffMs / (1000 * 60));
        const diffHours = Math.floor(diffMs / (1000 * 60 * 60));

        let timeText = '';
        if (diffMins < 1) {
          timeText = 'ë°©ê¸ˆ ì—…ë°ì´íŠ¸';
        } else if (diffMins < 60) {
          timeText = `${diffMins}ë¶„ ì „ ì—…ë°ì´íŠ¸`;
        } else if (diffHours < 24) {
          timeText = `${diffHours}ì‹œê°„ ì „ ì—…ë°ì´íŠ¸`;
        } else {
          timeText = lastUpdateTime.toLocaleString('ko-KR', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' }) + ' ì—…ë°ì´íŠ¸';
        }
        lastUpdateEl.textContent = timeText;
      }
    }

    // Update time display every minute
    setInterval(updateLastUpdateTime, 60000);

    // UI elements
    const feedListEl = document.getElementById('feed-list'), articleListEl = document.getElementById('article-list');
    const currentFeedTitleEl = document.getElementById('current-feed-title'), emptyStateEl = document.getElementById('empty-state');
    let currentFilter = null, articleFilter = 'unread', currentVisibleArticles = [], lastFocusedArticleGuid = null;
    let newArticleGuids = new Set();
    let lastUpdateTime = null;

    async function renderFeeds() {
      const feeds = await getAllFeeds();
      const feedListHTML = `
                <sl-menu>
                    <sl-menu-item data-url="all" class="${!currentFilter ? 'active' : ''}">ëª¨ë“  ê¸°ì‚¬</sl-menu-item>
                    <sl-divider></sl-divider>
                    ${feeds.map(feed => `
                        <sl-menu-item data-url="${feed.url}" class="${currentFilter === feed.url ? 'active' : ''}">
                            <div class="w-full flex justify-between items-center">
                                <span class="truncate pr-2">${feed.title || feed.url}</span>
                                <sl-icon-button name="x-lg" label="Delete" class="delete-feed-btn text-lg" data-url="${feed.url}"></sl-icon-button>
                            </div>
                        </sl-menu-item>
                    `).join('')}
                </sl-menu>
            `;
      feedListEl.innerHTML = feedListHTML;
      document.getElementById('mobile-sidebar-content').innerHTML = document.querySelector('#sidebar').innerHTML;
    }

    // ëŒ“ê¸€ ê°œìˆ˜ë¥¼ ë¹ ë¥´ê²Œ í™•ì¸í•˜ëŠ” í•¨ìˆ˜ (ìºì‹œ ì§€ì›)
    const commentCountCache = new Map();
    async function getCommentCount(url) {
      if (commentCountCache.has(url)) {
        return commentCountCache.get(url);
      }

      // news.hada.ioë‚˜ clien.netë§Œ ì§€ì›
      if (!url.includes('news.hada.io') && !url.includes('clien.net')) {
        commentCountCache.set(url, 0);
        return 0;
      }

      try {
        const comments = await fetchComments(url);
        const count = comments ? comments.length : 0;
        commentCountCache.set(url, count);
        return count;
      } catch (error) {
        console.error('Error getting comment count:', error);
        commentCountCache.set(url, 0);
        return 0;
      }
    }

    async function renderArticles(feedUrl = null) {
      const allArticles = await getArticles(feedUrl);
      const feeds = await getAllFeeds();
      const feedsMap = new Map(feeds.map(f => [f.url, f]));

      // Update tab counts
      const unreadCount = allArticles.filter(a => !a.read).length;
      const readCount = allArticles.filter(a => a.read).length;
      document.querySelector('sl-tab[panel="unread"]').innerHTML = `ì½ì§€ ì•ŠìŒ <sl-badge pill>${unreadCount}</sl-badge>`;
      document.querySelector('sl-tab[panel="read"]').innerHTML = `ì½ìŒ <sl-badge pill>${readCount}</sl-badge>`;
      document.querySelector('sl-tab[panel="all"]').innerHTML = `ëª¨ë‘ <sl-badge pill>${allArticles.length}</sl-badge>`;

      if (articleFilter === 'unread') currentVisibleArticles = allArticles.filter(a => !a.read);
      else if (articleFilter === 'read') currentVisibleArticles = allArticles.filter(a => a.read);
      else currentVisibleArticles = allArticles;

      articleListEl.innerHTML = '';
      emptyStateEl.classList.toggle('hidden', currentVisibleArticles.length > 0);
      document.getElementById('mark-all-read-btn').style.display = (articleFilter !== 'read' && currentVisibleArticles.length > 0) ? 'block' : 'none';

      // ëŒ“ê¸€ ê°œìˆ˜ë¥¼ ë³‘ë ¬ë¡œ ê°€ì ¸ì˜¤ê¸° (ì„±ëŠ¥ í–¥ìƒ)
      const commentPromises = currentVisibleArticles.map(article =>
        getCommentCount(article.link)
      );
      const commentCounts = await Promise.all(commentPromises);

      currentVisibleArticles.forEach((article, index) => {
        const feed = feedsMap.get(article.feedUrl);
        const faviconUrl = feed ? feed.faviconUrl : '';
        const articleEl = document.createElement('div');
        const newArticleClass = newArticleGuids.has(article.guid) ? 'new-article' : '';
        articleEl.className = `article-item group bg-white dark:bg-gray-800 p-4 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 cursor-pointer ${article.read ? 'read' : ''} ${newArticleClass}`;
        articleEl.dataset.guid = article.guid;
        articleEl.setAttribute('tabindex', '0'); // Make focusable
        const pubDate = new Date(article.pubDate).toLocaleString('ko-KR');
        const commentCount = commentCounts[index];
        const commentBadge = commentCount > 0 ? `<sl-badge variant="neutral" pill class="ml-2">ğŸ’¬ ${commentCount}</sl-badge>` : '';

        articleEl.innerHTML = `
                    <div class="flex items-start space-x-4">
                        <img src="${faviconUrl}" onerror="this.src='https://placehold.co/32x32/e2e8f0/64748b?text=RSS'; this.onerror=null;" class="w-8 h-8 rounded-full bg-gray-200" alt="í”¼ë“œ ì•„ì´ì½˜">
                        <div class="flex-1">
                            <div class="flex items-center">
                                <h3 class="text-lg font-bold text-blue-800 dark:text-blue-400 group-hover:underline flex-1">${article.title}</h3>
                                ${commentBadge}
                            </div>
                            <p class="text-sm text-gray-500 dark:text-gray-400 mt-1">${article.author || 'ì €ì ì—†ìŒ'} &middot; ${pubDate}</p>
                        </div>
                        <sl-button variant="${article.read ? 'default' : 'primary'}" size="small" pill class="toggle-read-btn">${article.read ? 'ì•ˆ ì½ìŒ' : 'ì½ìŒ'}</sl-button>
                    </div>`;
        articleListEl.appendChild(articleEl);
      });
    }

    // Feed parsing and syncing functions
    const loaderEl = document.getElementById('loader');
    async function fetchAndSaveFeed(feedUrl) {
      const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(feedUrl)}`;
      try {
        const response = await fetch(proxyUrl);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const xmlText = await response.text();

        const doc = new DOMParser().parseFromString(xmlText, 'application/xml');
        const parseError = doc.querySelector('parsererror');
        if (parseError) {
          console.error('XML Parsing Error:', parseError.textContent);
          throw new Error('ìœ íš¨í•˜ì§€ ì•Šì€ RSS í”¼ë“œ í˜•ì‹ì…ë‹ˆë‹¤.');
        }

        const feedTitle = doc.querySelector('channel > title')?.textContent || doc.querySelector('feed > title')?.textContent || 'Untitled Feed';
        const originalSiteLink = doc.querySelector('channel > link:not([rel])')?.textContent.trim() || doc.querySelector('feed > link[rel="alternate"]')?.getAttribute('href') || feedUrl;

        const items = Array.from(doc.querySelectorAll('item, entry'));
        const articles = items.map(item => {
          const title = item.querySelector('title')?.textContent || '[No Title]';
          const linkElement = item.querySelector('link');
          const link = linkElement?.getAttribute('href') || linkElement?.textContent.trim() || '';
          const guid = item.querySelector('guid')?.textContent || item.querySelector('id')?.textContent || link;
          const pubDate = item.querySelector('pubDate, published, updated')?.textContent || new Date().toISOString();
          const author = item.querySelector('author > name, creator')?.textContent || '';
          const content = item.querySelector('*|content, content')?.textContent || item.querySelector('description, summary')?.textContent || '';

          return { guid, title, link, author, pubDate: new Date(pubDate).toISOString(), content, feedUrl };
        });

        let faviconUrl = '';
        try {
          const domain = new URL(originalSiteLink).origin;
          faviconUrl = `https://www.google.com/s2/favicons?sz=32&domain_url=${domain}`;
        } catch (e) { console.warn("Could not determine domain for favicon for feed:", feedUrl); }

        await new Promise((resolve, reject) => {
          const tx = db.transaction([FEED_STORE], 'readwrite');
          const store = tx.objectStore(FEED_STORE);
          const feedData = { url: feedUrl, faviconUrl: faviconUrl, title: feedTitle };
          store.put(feedData);
          tx.oncomplete = () => resolve();
          tx.onerror = (e) => reject(e.target.error);
        });

        const result = await saveArticles(articles);
        const newArticles = result.newArticles || [];
        const newArticlesAdded = result.hasNewArticles || false;

        // Track new article GUIDs for visual separator
        newArticles.forEach(article => newArticleGuids.add(article.guid));

        return { feedTitle, newArticlesAdded, newArticleCount: newArticles.length };
      } catch (error) {
        console.error(`'${feedUrl}' í”¼ë“œ ê°€ì ¸ì˜¤ê¸° ì˜¤ë¥˜:`, error);
        throw error;
      }
    }
    async function refreshAllFeeds() {
      loaderEl.classList.remove('hidden');

      // Clear previous new article markers
      newArticleGuids.clear();

      const feeds = await getAllFeeds();
      const results = await Promise.allSettled(feeds.map(feed => fetchAndSaveFeed(feed.url)));

      let anyNewArticles = false;
      let totalNewArticles = 0;
      results.forEach(result => {
        if (result.status === 'fulfilled' && result.value.newArticlesAdded) {
          anyNewArticles = true;
          totalNewArticles += result.value.newArticleCount || 0;
        }
      });

      loaderEl.classList.add('hidden');
      await renderFeeds();
      await renderArticles(currentFilter);

      // Update last update time
      lastUpdateTime = new Date();
      updateLastUpdateTime();

      if (anyNewArticles) {
        showMessage(`ìƒˆë¡œìš´ ê¸°ì‚¬ ${totalNewArticles}ê°œë¥¼ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤.`, 'success');
      }
    }

    // Event handlers and detail view logic
    const mainContainer = document.getElementById('main-container'), detailContainer = document.getElementById('article-detail-container');
    const showMessage = (message, type = 'error', duration = 3000) => {
      const alert = document.createElement('sl-alert');
      let variant = 'danger';
      let icon = 'exclamation-octagon';
      if (type === 'success') {
        variant = 'success';
        icon = 'check2-circle';
      } else if (type === 'info') {
        variant = 'primary';
        icon = 'info-circle';
      }
      alert.variant = variant;
      alert.duration = duration;
      alert.innerHTML = `<sl-icon name="${icon}" slot="icon"></sl-icon>${message}`;

      alert.addEventListener('click', () => alert.hide());

      document.body.appendChild(alert);
      alert.toast();
    };

    async function fetchComments(url) {
      // news.hada.io ëŒ“ê¸€ ê°€ì ¸ì˜¤ê¸°
      if (url.includes('news.hada.io')) {
        try {
          const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
          const response = await fetch(proxyUrl);
          if (!response.ok) throw new Error('Network response was not ok.');
          const html = await response.text();

          const doc = new DOMParser().parseFromString(html, 'text/html');
          const comments = [];

          // news.hada.ioì˜ ëŒ“ê¸€ êµ¬ì¡° íŒŒì‹±
          let commentElements = [];

          const selectors = [
            'tr[id^="comment_tr_"]',
            '.comment_row',
            '[id^="cid"]',
            '#comment_thread .comment',
            '.comment',
            '[class*="comment"]'
          ];

          for (const selector of selectors) {
            commentElements = doc.querySelectorAll(selector);
            if (commentElements.length > 0) break;
          }

          commentElements.forEach((element, index) => {
            try {
              // ëŒ“ê¸€ ì‘ì„± í¼ì´ë‚˜ ê¸°íƒ€ UI ìš”ì†Œ ì œì™¸
              if (element.querySelector('form.write_comment') ||
                element.querySelector('textarea') ||
                element.querySelector('input[type="submit"]') ||
                element.classList.contains('write_comment') ||
                element.innerHTML.includes('ëŒ“ê¸€ ë‹¬ê¸°') ||
                element.innerHTML.includes('ëŒ“ê¸€ ì ê¸°')) {
                return;
              }

              // ì‘ì„±ì ì •ë³´
              const authorSelectors = ['a[href*="/user?id="]', 'a[href*="/user"]', '.author', '.username'];
              let author = 'ìµëª…';
              let hasValidAuthor = false;

              for (const selector of authorSelectors) {
                const authorEl = element.querySelector(selector);
                if (authorEl && authorEl.textContent.trim() && authorEl.textContent.trim() !== 'ìµëª…') {
                  author = authorEl.textContent.trim();
                  hasValidAuthor = true;
                  break;
                }
              }

              // ì‹œê°„ ì •ë³´
              const timeSelectors = ['.comment_meta', '.meta', '.time', '.date'];
              let timeText = '';
              let hasValidTime = false;

              for (const selector of timeSelectors) {
                const timeEl = element.querySelector(selector);
                if (timeEl) {
                  const textNodes = Array.from(timeEl.childNodes).filter(node => node.nodeType === Node.TEXT_NODE);
                  timeText = textNodes.map(node => node.textContent.trim()).filter(text => text).join(' ');
                  if (timeText && (timeText.includes('ì „') || timeText.includes('ì‹œê°„') || timeText.includes('ì¼'))) {
                    hasValidTime = true;
                    break;
                  }
                }
              }

              // ëŒ“ê¸€ ë‚´ìš©
              const contentSelectors = ['.comment_contents', '.contents', '.content', '.text', '.body'];
              let content = '';
              let htmlContent = '';
              let hasValidContent = false;

              for (const selector of contentSelectors) {
                const contentEl = element.querySelector(selector);
                if (contentEl) {
                  htmlContent = contentEl.innerHTML;
                  content = contentEl.textContent.trim();

                  // í¼ ê´€ë ¨ ë‚´ìš©ì´ë‚˜ ë¹ˆ ë‚´ìš© ì œì™¸
                  if (content &&
                    !content.includes('ëŒ“ê¸€ ë‹¬ê¸°') &&
                    !content.includes('ëŒ“ê¸€ ì ê¸°') &&
                    !content.includes('ì¸ì¦ ì´ë©”ì¼') &&
                    content.length > 10) {
                    hasValidContent = true;
                    break;
                  }
                }
              }

              // ì‹¤ì œ ëŒ“ê¸€ì¸ì§€ ê²€ì¦ (ì‘ì„±ìë‚˜ ì‹œê°„ ì •ë³´ê°€ ìˆê±°ë‚˜, ìœ íš¨í•œ ë‚´ìš©ì´ ìˆëŠ” ê²½ìš°ë§Œ)
              if ((hasValidAuthor || hasValidTime || hasValidContent) &&
                content && content.length > 10) {
                const commentId = element.id || `comment_${index + 1}`;

                comments.push({
                  id: commentId,
                  author: author,
                  time: timeText,
                  content: content,
                  htmlContent: htmlContent
                });
              }
            } catch (error) {
              console.error(`Error parsing comment ${index}:`, error);
            }
          });
          return comments;
        } catch (error) {
          console.error('Error fetching comments:', error);
          return [];
        }
      }

      // clien.net ëŒ“ê¸€ ê°€ì ¸ì˜¤ê¸°
      if (url.includes('clien.net')) {
        try {
          // URLì—ì„œ ê²Œì‹œê¸€ ID ì¶”ì¶œ
          const urlMatch = url.match(/\/([^\/]+)\/(\d+)$/);
          if (!urlMatch) {
            console.log('Could not extract board and post ID from URL:', url);
            return [];
          }

          const boardType = urlMatch[1]; // 'news'
          const postId = urlMatch[2]; // '19048102'

          console.log(`Clien.net: board=${boardType}, postId=${postId}`);

          // ë¨¼ì € ì¼ë°˜ í˜ì´ì§€ ë¡œë“œ ì‹œë„
          const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
          const response = await fetch(proxyUrl);
          if (!response.ok) throw new Error('Network response was not ok.');
          const html = await response.text();

          const doc = new DOMParser().parseFromString(html, 'text/html');
          let comments = [];

          // clien.netì˜ ëŒ“ê¸€ êµ¬ì¡° íŒŒì‹± - ì‹¤ì œ êµ¬ì¡° ê¸°ë°˜
          console.log('Clien.net comment parsing - using actual structure');

          // ëŒ“ê¸€ ì»¨í…Œì´ë„ˆ ì°¾ê¸°
          const commentContainer = doc.querySelector('.comment.ad_banner[data-role="comment"]');
          console.log('Comment container found:', !!commentContainer);

          if (!commentContainer) {
            // ë‹¤ë¥¸ ëŒ“ê¸€ ì»¨í…Œì´ë„ˆ selector ì‹œë„
            const alternativeSelectors = ['.comment.ad_banner', '.comment', '#comment-head', '[class*="comment"]'];
            for (const selector of alternativeSelectors) {
              const altContainer = doc.querySelector(selector);
              if (altContainer) {
                console.log(`Found alternative comment container with selector: ${selector}`);
                console.log('Container HTML preview:', altContainer.innerHTML.substring(0, 200) + '...');
                break;
              }
            }
          }

          if (commentContainer) {
            // comment_row ìš”ì†Œë“¤ ì°¾ê¸°
            const commentRows = commentContainer.querySelectorAll('.comment_row[data-role="comment-row"]');
            console.log(`Found ${commentRows.length} comment rows`);

            // ëŒ“ê¸€ ì»¨í…Œì´ë„ˆ ë‚´ìš© ë””ë²„ê¹…
            if (commentRows.length === 0) {
              console.log('Comment container HTML:', commentContainer.innerHTML.substring(0, 500) + '...');
              console.log('All children in comment container:', commentContainer.children.length);
              const allRows = commentContainer.querySelectorAll('.comment_row');
              console.log(`Found ${allRows.length} rows without data-role filter`);
              const allCommentDivs = commentContainer.querySelectorAll('div[class*="comment"]');
              console.log(`Found ${allCommentDivs.length} divs with comment in class`);
            }

            commentRows.forEach((row, index) => {
              try {
                // ë°ì´í„° ì†ì„±ì—ì„œ ì •ë³´ ì¶”ì¶œ
                const authorId = row.getAttribute('data-author-id');
                const commentSn = row.getAttribute('data-comment-sn');
                const isReply = row.classList.contains('re');

                console.log(`Processing comment row ${index + 1}: author=${authorId}, sn=${commentSn}, isReply=${isReply}`);

                // ë‹‰ë„¤ì„ ì¶”ì¶œ
                const nicknameEl = row.querySelector('.nickname');
                let author = authorId || 'í´ë¦¬ì•™ ì‚¬ìš©ì';
                if (nicknameEl && nicknameEl.textContent.trim()) {
                  author = nicknameEl.textContent.trim();
                }

                // ëŒ“ê¸€ ë‚´ìš© ì¶”ì¶œ
                const contentEl = row.querySelector('.comment_view');
                let content = '';
                let htmlContent = '';
                if (contentEl) {
                  content = contentEl.textContent.trim();
                  htmlContent = contentEl.innerHTML;
                } else {
                  // comment_viewê°€ ì—†ìœ¼ë©´ ì „ì²´ í…ìŠ¤íŠ¸ì—ì„œ ì¶”ì¶œ
                  const fullText = row.textContent.trim();
                  const lines = fullText.split('\n').filter(line => line.trim());
                  for (const line of lines) {
                    if (line.length > 5 &&
                      !line.includes('ê³µê°') &&
                      !line.includes('ì‹ ê³ ') &&
                      !line.includes('ëŒ€ëŒ“ê¸€') &&
                      !line.match(/^\d+$/)) {
                      content = line;
                      break;
                    }
                  }
                }

                // ì‹œê°„ ì •ë³´ ì¶”ì¶œ
                const timeEl = row.querySelector('.time, .date, [class*="time"], [class*="date"]');
                let timeText = '';
                if (timeEl) {
                  timeText = timeEl.textContent.trim();
                } else {
                  // í…ìŠ¤íŠ¸ì—ì„œ ì‹œê°„ íŒ¨í„´ ì°¾ê¸°
                  const fullText = row.textContent;
                  const timeMatch = fullText.match(/\d{2}-\d{2}-\d{2}\s+\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}/);
                  if (timeMatch) {
                    timeText = timeMatch[0];
                  }
                }

                // ìœ íš¨í•œ ëŒ“ê¸€ë§Œ ì¶”ê°€
                if (content && content.length > 1) {
                  comments.push({
                    id: commentSn || (index + 1),
                    author: author,
                    time: timeText,
                    content: content,
                    htmlContent: htmlContent || content,
                    isReply: isReply,
                    depth: isReply ? 1 : 0,
                    authorId: authorId
                  });
                  console.log(`Added ${isReply ? 'reply' : 'comment'} ${index + 1}: ${author} - ${content.substring(0, 30)}...`);
                } else {
                  console.log(`Skipped row ${index + 1} - no valid content`);
                }
              } catch (error) {
                console.error(`Error parsing comment row ${index}:`, error);
              }
            });
          }

          console.log(`Structure-based parsing found ${comments.length} comments`);

          // êµ¬ì¡° ê¸°ë°˜ìœ¼ë¡œ ì°¾ì§€ ëª»í•œ ê²½ìš° í…ìŠ¤íŠ¸ ê¸°ë°˜ íŒŒì‹± ì‚¬ìš© (ê°œì„ ë¨)
          if (comments.length === 0) {
            console.log('Fallback to text-based parsing');
            console.log('Document body length:', doc.body.textContent.length);

            // ë‹¤ì–‘í•œ ëŒ“ê¸€ ì„¹ì…˜ selector ì‹œë„
            const commentSectionSelectors = ['#comment-head', '#comments', '.comments', '[id*="comment"]'];
            let commentSection = null;

            for (const selector of commentSectionSelectors) {
              commentSection = doc.querySelector(selector);
              if (commentSection) {
                console.log(`Found comment section with selector: ${selector}`);
                break;
              }
            }

            // ì „ì²´ í˜ì´ì§€ì—ì„œ ëŒ“ê¸€ í…ìŠ¤íŠ¸ ì°¾ê¸°
            const textContent = commentSection ? commentSection.textContent : doc.body.textContent;
            const lines = textContent.split('\n').map(line => line.trim()).filter(line => line.length > 0);

            console.log(`Processing ${lines.length} text lines for comments`);

            // ëŒ“ê¸€ ID íŒ¨í„´ì´ ìˆëŠ”ì§€ ë¨¼ì € í™•ì¸
            const allText = textContent;
            const commentIdMatches = allText.match(/#\d{9,}/g);
            console.log(`Found ${commentIdMatches ? commentIdMatches.length : 0} comment ID patterns in text:`, commentIdMatches ? commentIdMatches.slice(0, 5) : 'none');

            // í…ìŠ¤íŠ¸ ìƒ˜í”Œ ë¡œê·¸ (ì²˜ìŒ 10ì¤„)
            console.log('First 10 lines of text:', lines.slice(0, 10));

            // ëŒ“ê¸€ ID íŒ¨í„´ìœ¼ë¡œ ëª¨ë“  ëŒ“ê¸€ ì°¾ê¸° (ëŒ€ëŒ“ê¸€ í¬í•¨)
            let currentComment = null;
            let commentCount = 0;
            let collectingContent = false;

            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];

              // ëŒ“ê¸€ ID íŒ¨í„´ (#ìˆ«ì - 8ìë¦¬ ì´ìƒ) ë˜ëŠ” ëŒ€ëŒ“ê¸€ íŒ¨í„´
              const commentIdMatch = line.match(/^#\d{9,}$/) || line.match(/^Re:\s*#\d{9,}$/);
              if (commentIdMatch) {
                console.log(`Found comment ID pattern: ${line}`);
                if (currentComment && currentComment.content && currentComment.content.length > 5) {
                  comments.push(currentComment);
                  commentCount++;
                }
                const isReply = line.startsWith('Re:');
                currentComment = {
                  id: line,
                  author: 'í´ë¦¬ì•™ ì‚¬ìš©ì',
                  time: '',
                  content: '',
                  isReply: isReply,
                  depth: isReply ? 1 : 0
                };
                collectingContent = false;
                console.log(`Found ${isReply ? 'reply' : 'comment'} ID: ${line}`);
              }
              // ë‹‰ë„¤ì„ íŒ¨í„´ (í•œê¸€, ì˜ë¬¸, ìˆ«ì, íŠ¹ìˆ˜ë¬¸ì ì¡°í•©)
              else if (currentComment && !currentComment.authorSet && line.match(/^[ê°€-í£a-zA-Z0-9_\-\[\]()]+$/)) {
                // IPë‚˜ ë‚ ì§œê°€ ì•„ë‹Œ ê²½ìš°ë§Œ ë‹‰ë„¤ì„ìœ¼ë¡œ ì²˜ë¦¬
                if (!line.startsWith('IP') && !line.match(/\d{2}-\d{2}-\d{2}/) && line.length <= 20) {
                  currentComment.author = line;
                  currentComment.authorSet = true;
                  console.log(`Found author: ${line}`);
                }
              }
              // IP ì£¼ì†Œ íŒ¨í„´
              else if (line.startsWith('IP ')) {
                if (currentComment) {
                  currentComment.ip = line;
                  // IP ì´í›„ë¶€í„° ëŒ“ê¸€ ë‚´ìš© ìˆ˜ì§‘ ì‹œì‘
                  collectingContent = true;
                }
              }
              // ë‚ ì§œ/ì‹œê°„ íŒ¨í„´
              else if (line.match(/\d{2}-\d{2}-\d{2}\s+\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}/)) {
                if (currentComment) {
                  currentComment.time = line;
                  collectingContent = true;
                }
              }
              // ì•¡ì…˜ ë¼ì¸ë“¤ ìŠ¤í‚µ
              else if (line.includes('ëŒ€ëŒ“ê¸€') || line.includes('ê³µê°') || line.includes('ì‹ ê³ ') ||
                line === 'LINK' || line.match(/^\d+$/)) {
                continue;
              }
              // ì‹¤ì œ ëŒ“ê¸€ ë‚´ìš© ìˆ˜ì§‘ (ì—¬ëŸ¬ ì¤„ ì§€ì›)
              else if (currentComment && line.length > 3) {
                // ì‹œìŠ¤í…œ ë©”ì‹œì§€ë‚˜ UI í…ìŠ¤íŠ¸ ì œì™¸í•˜ê³  ì‹¤ì œ ëŒ“ê¸€ ë‚´ìš© ì°¾ê¸°
                if (!line.includes('ëŒ€ëŒ“ê¸€') &&
                  !line.includes('ê³µê°') &&
                  !line.includes('ì‹ ê³ ') &&
                  !line.includes('ë“±ë¡') &&
                  !line.includes('ìˆ˜ì •') &&
                  !line.includes('ì‚­ì œ') &&
                  !line.includes('ë¡œê·¸ì¸') &&
                  !line.includes('ìƒˆë¡œê³ ì¹¨') &&
                  !line.includes('ëª©ë¡') &&
                  !line.startsWith('IP ') &&
                  !line.match(/\d{2}-\d{2}-\d{2}/) &&
                  !line.match(/^\d+$/) &&
                  line !== 'LINK' &&
                  !line.match(/^(ì˜ˆ|ì•„ë‹ˆì˜¤|í™•ì¸|ì·¨ì†Œ|ë‹«ê¸°)$/)) {

                  // ì²« ë²ˆì§¸ ë‚´ìš©ì´ê±°ë‚˜ ê¸°ì¡´ ë‚´ìš©ì— ì¶”ê°€
                  if (!currentComment.content) {
                    currentComment.content = line;
                    collectingContent = true;
                    console.log(`Found content start: ${line.substring(0, 50)}...`);
                  } else if (collectingContent) {
                    // ê¸´ ëŒ“ê¸€ì˜ ì—°ì†ëœ ì¤„ ì¶”ê°€
                    currentComment.content += '\n' + line;
                    console.log(`Added content line: ${line.substring(0, 30)}...`);
                  }
                }
              }
            }

            // ë§ˆì§€ë§‰ ëŒ“ê¸€ ì¶”ê°€
            if (currentComment && currentComment.content && currentComment.content.length > 5) {
              comments.push(currentComment);
              commentCount++;
            }

            console.log(`Text-based parsing found ${commentCount} comments`);

            // ë§ˆì§€ë§‰ìœ¼ë¡œ ì „ì²´ HTMLì—ì„œ ëŒ“ê¸€ íŒ¨í„´ ì§ì ‘ ê²€ìƒ‰
            if (comments.length === 0) {
              console.log('Final attempt: searching entire HTML for comment patterns');
              const fullHtml = html;

              // ë‹¤ì–‘í•œ ëŒ“ê¸€ íŒ¨í„´ ê²€ìƒ‰
              const patterns = [
                /#\d{9,}/g,  // ëŒ“ê¸€ ID
                /data-comment-sn="(\d+)"/g,  // ëŒ“ê¸€ ì‹œë¦¬ì–¼ ë„˜ë²„
                /data-author-id="([^"]+)"/g,  // ì‘ì„±ì ID
              ];

              patterns.forEach((pattern, index) => {
                const matches = fullHtml.match(pattern);
                console.log(`Pattern ${index + 1} matches:`, matches ? matches.length : 0, matches ? matches.slice(0, 3) : 'none');
              });

              // ëŒ“ê¸€ ê´€ë ¨ í…ìŠ¤íŠ¸ ì§ì ‘ ì¶”ì¶œ ì‹œë„
              const commentRegex = /IP\s+\d+\.\â™¡\.\d+\.\d+[\s\S]*?(?=#\d+|$)/g;
              const directMatches = fullHtml.match(commentRegex);
              if (directMatches && directMatches.length > 0) {
                console.log(`Found ${directMatches.length} direct comment patterns`);
                directMatches.forEach((match, index) => {
                  if (index < 3) {  // ì²˜ìŒ 3ê°œë§Œ ë¡œê·¸
                    console.log(`Direct match ${index + 1}:`, match.substring(0, 100) + '...');
                  }
                });
              }
            }
          }

          console.log(`Final result: ${comments.length} comments found`);

          return comments.map((comment, index) => ({
            id: comment.id || index + 1,
            author: comment.author || 'í´ë¦¬ì•™ ì‚¬ìš©ì',
            time: comment.time || '',
            content: comment.content || '',
            htmlContent: comment.htmlContent || comment.content,
            isReply: comment.isReply || false,
            depth: comment.depth || 0,
            authorId: comment.authorId
          }));
        } catch (error) {
          console.error('Error fetching clien.net comments:', error);
          return [];
        }
      }

      // ë‹¤ë¥¸ ì‚¬ì´íŠ¸ëŠ” ë¹ˆ ë°°ì—´ ë°˜í™˜
      return [];
    }

    async function fetchAndDisplayFullContent(url, fallbackContent) {
      const detailContentEl = document.getElementById('detail-content');
      detailContentEl.innerHTML = '<div class="flex justify-center items-center p-8"><sl-spinner class="text-4xl"></sl-spinner></div>';
      try {
        const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
        const response = await fetch(proxyUrl);
        if (!response.ok) throw new Error('Network response was not ok.');
        const html = await response.text();

        const doc = new DOMParser().parseFromString(html, 'text/html');
        doc.baseURI = url;
        const reader = new Readability(doc);
        const article = reader.parse();

        if (article && article.content) {
          detailContentEl.innerHTML = article.content;
        } else {
          throw new Error('Readability could not parse the article.');
        }

        // ëŒ“ê¸€ ê°€ì ¸ì˜¤ê¸° ë° í‘œì‹œ
        console.log(`Fetching comments for URL: ${url}`);
        const comments = await fetchComments(url);
        console.log(`Fetched ${comments.length} comments:`, comments);
        if (comments.length > 0) {
          const commentsHtml = `
            <div id="comments-section" class="mt-12 pt-8 border-t dark:border-gray-700">
              <h3 class="text-xl font-bold mb-6 text-gray-900 dark:text-gray-100">ëŒ“ê¸€ ${comments.length}ê°œ</h3>
              <div class="space-y-4">
                ${comments.map(comment => `
                  <div class="${comment.isReply ? 'ml-8 border-l-2 border-blue-200 dark:border-blue-800' : ''} bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
                    <div class="flex items-center justify-between mb-2">
                      <div class="flex items-center">
                        ${comment.isReply ? '<span class="text-blue-500 mr-2">â†³</span>' : ''}
                        <span class="font-semibold text-gray-900 dark:text-gray-100">${comment.author}</span>
                        ${comment.isReply ? '<span class="ml-2 text-xs bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200 px-2 py-1 rounded">ë‹µê¸€</span>' : ''}
                      </div>
                      <span class="text-sm text-gray-500 dark:text-gray-400">${comment.time}</span>
                    </div>
                    <div class="comment-content text-gray-700 dark:text-gray-300">${comment.htmlContent || comment.content}</div>
                  </div>
                `).join('')}
              </div>
            </div>
          `;
          console.log(`Adding comments HTML to detail content`);
          detailContentEl.innerHTML += commentsHtml;
        } else {
          console.log(`No comments found for URL: ${url}`);
          // ëŒ“ê¸€ì´ ì—†ëŠ” ê²½ìš°ì—ë„ ì‚¬ìš©ìì—ê²Œ ì•Œë¦¼ í‘œì‹œ
          if (url.includes('clien.net') || url.includes('news.hada.io')) {
            const noCommentsHtml = `
              <div id="comments-section" class="mt-12 pt-8 border-t dark:border-gray-700">
                <h3 class="text-xl font-bold mb-6 text-gray-900 dark:text-gray-100">ëŒ“ê¸€</h3>
                <div class="bg-gray-50 dark:bg-gray-800 rounded-lg p-4 text-center">
                  <p class="text-gray-600 dark:text-gray-400">
                    ëŒ“ê¸€ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. 
                    <a href="${url}" target="_blank" class="text-blue-600 dark:text-blue-400 hover:underline">
                      ì›ë³¸ í˜ì´ì§€ì—ì„œ í™•ì¸í•˜ê¸°
                    </a>
                  </p>
                </div>
              </div>
            `;
            detailContentEl.innerHTML += noCommentsHtml;
          }
        }

      } catch (error) {
        console.error('Error fetching full content:', error);
        detailContentEl.innerHTML = fallbackContent + '<p class="text-red-500 mt-4">ì „ì²´ ê¸°ì‚¬ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ìš”ì•½ë³¸ì„ í‘œì‹œí•©ë‹ˆë‹¤.</p>';
      } finally {
        detailContentEl.querySelectorAll('pre code').forEach((block) => {
          hljs.highlightElement(block);
        });
      }
    }

    async function updateDetailView(guid) {
      await setArticleReadStatus(guid, true);
      const article = await getArticleByGuid(guid);
      if (!article) return;
      document.getElementById('detail-title').textContent = article.title;
      document.getElementById('detail-author').textContent = `${article.author || 'ì €ì ì—†ìŒ'} Â· ${new Date(article.pubDate).toLocaleString('ko-KR')}`;
      document.getElementById('detail-link-btn').href = article.link;
      document.getElementById('detail-scroll-container').scrollTop = 0;

      const detailContentEl = document.getElementById('detail-content');
      const MIN_LENGTH_FOR_FULL_CONTENT = 1500;
      if (article.content && article.content.length > MIN_LENGTH_FOR_FULL_CONTENT) {
        detailContentEl.innerHTML = article.content;
        detailContentEl.querySelectorAll('pre code').forEach((block) => {
          hljs.highlightElement(block);
        });
      } else {
        fetchAndDisplayFullContent(article.link, article.content);
      }

      const currentIndex = currentVisibleArticles.findIndex(a => a.guid === guid);
      const prevBtn = document.getElementById('detail-prev-btn'), nextBtn = document.getElementById('detail-next-btn');
      prevBtn.disabled = currentIndex <= 0;
      nextBtn.disabled = currentIndex >= currentVisibleArticles.length - 1;
      prevBtn.dataset.guid = currentIndex > 0 ? currentVisibleArticles[currentIndex - 1].guid : '';
      nextBtn.dataset.guid = currentIndex < currentVisibleArticles.length - 1 ? currentVisibleArticles[currentIndex + 1].guid : '';
    }

    function showDetailView(guid, fromPopState = false) {
      lastFocusedArticleGuid = guid;
      mainContainer.classList.add('hidden');
      detailContainer.classList.remove('hidden');
      updateDetailView(guid);
      if (!fromPopState) {
        history.pushState({ guid: guid }, '', `#detail/${encodeURIComponent(guid)}`);
      }
    }

    function hideDetailView(fromPopState = false) {
      mainContainer.classList.remove('hidden');
      detailContainer.classList.add('hidden');
      renderArticles(currentFilter).then(() => {
        if (lastFocusedArticleGuid) {
          const lastFocusedEl = articleListEl.querySelector(`[data-guid="${lastFocusedArticleGuid}"]`);
          if (lastFocusedEl) {
            lastFocusedEl.focus();
          }
        }
      });
      if (!fromPopState) {
        history.pushState({}, '', window.location.pathname + window.location.search);
      }
    }

    // Use event delegation to handle form submission for both desktop and mobile
    document.body.addEventListener('submit', async (e) => {
      if (e.target.id !== 'add-feed-form') return;
      e.preventDefault();
      const urlsTextarea = e.target.querySelector('#feed-urls');
      const submitButton = e.target.querySelector('sl-button[type="submit"]');
      const urls = urlsTextarea.value.split('\n').map(url => url.trim()).filter(url => url && url.startsWith('http'));

      if (urls.length === 0) {
        showMessage('ìœ íš¨í•œ URLì„ ì…ë ¥í•´ì£¼ì„¸ìš”.', 'error');
        return;
      }

      // ë²„íŠ¼ ë¡œë”© ìƒíƒœ ì‹œì‘
      submitButton.loading = true;
      submitButton.disabled = true;
      loaderEl.classList.remove('hidden');

      const existingFeeds = await getAllFeeds();
      const existingUrls = new Set(existingFeeds.map(f => f.url));
      const newUrls = urls.filter(url => !existingUrls.has(url));

      if (newUrls.length === 0) {
        showMessage('ì…ë ¥ëœ ëª¨ë“  í”¼ë“œê°€ ì´ë¯¸ ì¶”ê°€ë˜ì–´ ìˆìŠµë‹ˆë‹¤.', 'info');
        // ë²„íŠ¼ ë¡œë”© ìƒíƒœ ì¢…ë£Œ
        submitButton.loading = false;
        submitButton.disabled = false;
        loaderEl.classList.add('hidden');
        urlsTextarea.value = '';
        return;
      }

      const results = await Promise.allSettled(newUrls.map(url => fetchAndSaveFeed(url)));

      let successfulCount = 0;
      let failedCount = 0;
      let totalNewArticlesFromFeeds = 0;
      results.forEach(result => {
        if (result.status === 'fulfilled') {
          successfulCount++;
          totalNewArticlesFromFeeds += result.value.newArticleCount || 0;
        }
        else {
          failedCount++;
          console.error('í”¼ë“œ ì¶”ê°€ ì‹¤íŒ¨:', result.reason);
        }
      });

      urlsTextarea.value = '';
      await renderFeeds();
      await renderArticles(currentFilter);

      // ë²„íŠ¼ ë¡œë”© ìƒíƒœ ì¢…ë£Œ
      submitButton.loading = false;
      submitButton.disabled = false;
      loaderEl.classList.add('hidden');

      let message = '';
      if (successfulCount > 0) {
        message += `${successfulCount}ê°œì˜ í”¼ë“œë¥¼ ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.`;
        if (totalNewArticlesFromFeeds > 0) {
          message += ` (ìƒˆ ê¸°ì‚¬ ${totalNewArticlesFromFeeds}ê°œ)`;
        }
        message += ' ';
      }
      if (failedCount > 0) message += `${failedCount}ê°œ ì¶”ê°€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.`;
      const messageType = successfulCount > 0 ? 'success' : 'error';
      showMessage(message.trim(), messageType);

      // Update last update time when adding feeds
      if (successfulCount > 0) {
        lastUpdateTime = new Date();
        updateLastUpdateTime();
      }
    });

    document.body.addEventListener('sl-select', async (e) => {
      const selectedItem = e.detail.item;
      if (selectedItem.closest('#feed-list') || selectedItem.closest('#mobile-sidebar-content')) {
        const url = selectedItem.dataset.url;
        currentFilter = (url === 'all') ? null : url;

        const feed = (await getAllFeeds()).find(f => f.url === url);
        currentFeedTitleEl.textContent = feed ? (feed.title || url) : 'ëª¨ë“  ê¸°ì‚¬';
        await renderFeeds();
        await renderArticles(currentFilter);

        const drawer = document.getElementById('mobile-sidebar-drawer');
        if (drawer.open) drawer.hide();
      }
    });

    document.body.addEventListener('click', async (e) => {
      const deleteBtn = e.target.closest('.delete-feed-btn');
      if (deleteBtn) {
        e.stopPropagation();
        const url = deleteBtn.dataset.url;
        if (confirm(`'${url}' í”¼ë“œë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
          await deleteFeed(url);
          if (currentFilter === url) { currentFilter = null; currentFeedTitleEl.textContent = 'ëª¨ë“  ê¸°ì‚¬'; }
          await renderFeeds(); await renderArticles(currentFilter);
        }
      }
    });

    articleListEl.addEventListener('click', async (e) => {
      const articleItem = e.target.closest('.article-item');
      if (!articleItem) return;
      const guid = articleItem.dataset.guid;
      if (e.target.closest('.toggle-read-btn')) {
        e.stopPropagation();
        const article = await getArticleByGuid(guid);
        await setArticleReadStatus(guid, !article.read);
        await renderArticles(currentFilter);
      } else {
        showDetailView(guid);
      }
    });
    articleListEl.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
        e.preventDefault();
        const items = Array.from(articleListEl.querySelectorAll('.article-item'));
        const currentItem = document.activeElement;
        const currentIndex = items.indexOf(currentItem);

        if (e.key === 'ArrowDown' && currentIndex < items.length - 1) {
          items[currentIndex + 1].focus();
        } else if (e.key === 'ArrowUp' && currentIndex > 0) {
          items[currentIndex - 1].focus();
        }
      } else if (e.key === ' ') {
        e.preventDefault();
        if (document.activeElement.classList.contains('article-item')) {
          document.activeElement.click();
        }
      }
    });

    // í‚¤ë³´ë“œ ì´ë²¤íŠ¸ë¥¼ ì—¬ëŸ¬ ë°©ë²•ìœ¼ë¡œ ì²˜ë¦¬
    function setupKeyboardHandlers() {
      const handlers = [
        { target: document, event: 'keydown' },
        { target: document, event: 'keypress' },
        { target: window, event: 'keydown' },
        { target: document.body, event: 'keydown' }
      ];

      const handleKey = (e) => {
        // ì…ë ¥ í•„ë“œì—ì„œ í‚¤ ì…ë ¥ ì‹œ ë¬´ì‹œ
        if (e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) {
          return;
        }

        const helpModal = document.getElementById('help-modal');
        const detailContainer = document.getElementById('article-detail-container');
        const isDetailViewVisible = detailContainer && !detailContainer.classList.contains('hidden');

        console.log('Key pressed:', e.key, 'Detail view visible:', isDetailViewVisible); // ë””ë²„ê¹…

        if (e.key === 'Backspace') {
          e.preventDefault();
          e.stopPropagation();
          if (helpModal && helpModal.open) {
            helpModal.hide();
          } else if (isDetailViewVisible) {
            hideDetailView();
          }
          return;
        }

        if (isDetailViewVisible) {
          if (e.key === 'ArrowRight') {
            document.getElementById('detail-next-btn').click();
          } else if (e.key === 'ArrowLeft') {
            document.getElementById('detail-prev-btn').click();
          } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
            e.preventDefault();
            const container = document.getElementById('detail-scroll-container');
            const scrollAmount = 120;
            if (e.key === 'ArrowDown') {
              container.scrollBy({ top: scrollAmount, behavior: 'smooth' });
            } else {
              container.scrollBy({ top: -scrollAmount, behavior: 'smooth' });
            }
          }
        }
      };

      handlers.forEach(({ target, event }) => {
        target.addEventListener(event, handleKey, { capture: true });
      });
    }

    // DOM ë¡œë“œ í›„ í•¸ë“¤ëŸ¬ ì„¤ì •
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', setupKeyboardHandlers);
    } else {
      setupKeyboardHandlers();
    }

    document.getElementById('article-filter-tabs').addEventListener('sl-tab-show', (e) => {
      articleFilter = e.detail.name;
      renderArticles(currentFilter);
    });
    document.getElementById('detail-prev-btn').addEventListener('click', (e) => {
      if (!e.currentTarget.disabled) updateDetailView(e.currentTarget.dataset.guid);
    });
    document.getElementById('detail-next-btn').addEventListener('click', (e) => {
      if (!e.currentTarget.disabled) updateDetailView(e.currentTarget.dataset.guid);
    });
    document.getElementById('mark-all-read-btn').addEventListener('click', async () => {
      const articlesToUpdate = currentVisibleArticles.filter(a => !a.read);
      if (articlesToUpdate.length === 0) return;
      const tx = db.transaction([ARTICLE_STORE], 'readwrite');
      articlesToUpdate.forEach(article => { article.read = true; tx.objectStore(ARTICLE_STORE).put(article); });
      tx.oncomplete = async () => renderArticles(currentFilter);
    });

    document.getElementById('detail-back-btn').addEventListener('click', () => history.back());

    // Help Modal Logic
    document.getElementById('help-btn').addEventListener('click', () => document.getElementById('help-modal').show());

    // Mobile Menu Logic
    document.getElementById('menu-btn').addEventListener('click', () => document.getElementById('mobile-sidebar-drawer').show());

    // Resizer Logic
    const resizer = document.getElementById('resizer');
    const sidebar = document.getElementById('sidebar');
    resizer.addEventListener('mousedown', function (e) {
      e.preventDefault();
      document.body.style.cursor = 'col-resize';
      document.body.style.userSelect = 'none';

      let animationFrameId = null;
      function onMouseMove(e) {
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
        }
        animationFrameId = requestAnimationFrame(() => {
          const newWidth = e.clientX;
          const containerRect = sidebar.parentElement.getBoundingClientRect();
          const newRelativeWidth = (newWidth - containerRect.left) / containerRect.width * 100;
          document.documentElement.style.setProperty('--sidebar-width', `${newRelativeWidth}%`);
        });
      }

      function onMouseUp() {
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
        localStorage.setItem('sidebarWidth', document.documentElement.style.getPropertyValue('--sidebar-width'));
      }

      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });

    // Router Logic
    window.addEventListener('popstate', (event) => {
      const guid = event.state?.guid;
      if (guid) {
        showDetailView(guid, true);
      } else {
        hideDetailView(true);
      }
    });

    // Theme Logic
    const themeMenu = document.getElementById('theme-menu');
    const themeToggleButton = document.querySelector('sl-dropdown sl-icon-button');
    const html = document.documentElement;

    function applyTheme(theme) {
      const isDark = theme === 'dark' || (theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches);

      html.classList.toggle('dark', isDark);
      html.classList.toggle('sl-theme-dark', isDark);
      themeToggleButton.name = isDark ? 'moon-stars' : 'sun';

      themeMenu.querySelectorAll('sl-menu-item').forEach(item => {
        const checkIcon = item.querySelector('sl-icon[slot="suffix"]');
        checkIcon.style.visibility = item.value === theme ? 'visible' : 'hidden';
      });
    }

    themeMenu.addEventListener('sl-select', event => {
      const theme = event.detail.item.value;
      localStorage.setItem('rss-theme', theme);
      applyTheme(theme);
    });

    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
      const currentTheme = localStorage.getItem('rss-theme') || 'system';
      if (currentTheme === 'system') {
        applyTheme('system');
      }
    });

    // 7. ì•± ì‹œì‘
    window.addEventListener('load', async () => {
      const globalLoader = document.getElementById('global-loader');
      try {
        const savedWidth = localStorage.getItem('sidebarWidth');
        if (savedWidth) {
          document.documentElement.style.setProperty('--sidebar-width', savedWidth);
        }

        const savedTheme = localStorage.getItem('rss-theme') || 'system';
        applyTheme(savedTheme);

        await initDB();
        await renderFeeds();
        document.querySelector(`sl-tab[panel="${articleFilter}"]`).active = true;

        const initialHash = window.location.hash;
        if (initialHash.startsWith('#detail/')) {
          const guid = decodeURIComponent(initialHash.substring(8));
          await refreshAllFeeds();
          showDetailView(guid, true);
        } else {
          await renderArticles();
          await refreshAllFeeds();
        }
      } catch (error) {
        console.error("ì•± ì´ˆê¸°í™” ì‹¤íŒ¨:", error);
        document.body.innerHTML = '<div class="p-4 text-red-600">ì•± ì´ˆê¸°í™” ì‹¤íŒ¨. IndexedDBë¥¼ ì§€ì›í•˜ëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.</div>';
      } finally {
        globalLoader.style.opacity = '0';
        setTimeout(() => {
          globalLoader.style.display = 'none';
        }, 300);
      }
    });
  </script>
</body>

</html>