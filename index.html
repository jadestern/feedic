<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <link rel="icon" type="image/x-icon" href="public/favicon.ico" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="RSS Reader" />
  <link rel="apple-touch-icon" sizes="180x180" href="public/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="public/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="public/favicon-16x16.png" />
  <link rel="manifest" href="public/site.webmanifest" />
  <title>RSS Reader</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    // Configure Tailwind CSS for dark mode
    tailwind.config = {
      darkMode: 'class',
    }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/@mozilla/readability@0.5.0/Readability.js"></script>
  <!-- highlight.js for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  
  <!-- date-fns for relative time formatting -->
  <script src="https://cdn.jsdelivr.net/npm/date-fns@2.29.3/index.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/date-fns@2.29.3/locale/ko/index.min.js"></script>

  <!-- Shoelace Web Components -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.1/cdn/themes/light.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.1/cdn/themes/dark.css" />
  <script type="module" src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.15.1/cdn/shoelace.js"></script>

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      box-sizing: border-box;
    }

    html,
    body {
      width: 100%;
      max-width: 100vw;
      overflow-x: hidden;
    }

    body {
      font-family: 'Inter', sans-serif;
      --sl-font-sans: 'Inter', sans-serif;
      word-break: break-word;
      word-wrap: break-word;
      overflow-wrap: anywhere;
    }

    .feed-item.active {
      background-color: var(--sl-color-primary-50);
    }

    .article-item.read {
      opacity: 0.6;
    }

    .loader {
      font-size: 2rem;
    }

    #detail-content h1,
    #detail-content h2,
    #detail-content h3 {
      font-size: 1.5em;
      font-weight: bold;
      margin-top: 1.2em;
      margin-bottom: 0.6em;
    }

    #detail-content p {
      margin-bottom: 1em;
      line-height: 1.6;
    }

    #detail-content a {
      color: var(--sl-color-primary-600);
      text-decoration: underline;
    }

    #detail-content img {
      max-width: 100%;
      height: auto;
      border-radius: 0.5rem;
      margin: 1em 0;
    }

    #detail-content ul,
    #detail-content ol {
      padding-left: 1.5em;
      margin-bottom: 1em;
      margin-top: 0.5em;
    }

    #detail-content ul {
      list-style-type: disc;
    }

    #detail-content ol {
      list-style-type: decimal;
    }

    #detail-content ul ul {
      list-style-type: circle;
      margin-top: 0.25em;
      margin-bottom: 0.25em;
    }

    #detail-content ol ol {
      list-style-type: lower-alpha;
      margin-top: 0.25em;
      margin-bottom: 0.25em;
    }

    #detail-content li {
      margin-bottom: 0.5em;
      line-height: 1.6;
      padding-left: 0.25em;
    }

    #detail-content li>p {
      margin-bottom: 0.5em;
    }

    #detail-content li:last-child {
      margin-bottom: 0;
    }

    /* Styling for code blocks */
    #detail-content pre {
      background-color: #282c34;
      color: #abb2bf;
      padding: 1.25em;
      border-radius: 0.5rem;
      overflow-x: auto;
      font-size: 0.9em;
    }

    #detail-content pre code.hljs {
      padding: 0;
    }

    /* Style for keyboard focus */
    .article-item:focus-visible {
      outline: 2px solid var(--sl-color-primary-600);
      outline-offset: 2px;
      box-shadow: 0 0 0 4px var(--sl-color-primary-200);
    }

    /* Resizable layout */
    .app-container {
      display: flex;
      height: 100vh;
      --sidebar-width: 25%;
    }

    #sidebar {
      width: var(--sidebar-width);
      min-width: 200px;
      max-width: 50%;
    }

    #resizer {
      width: 5px;
      cursor: col-resize;
      background-color: #e5e7eb;
      flex-shrink: 0;
    }

    .dark #resizer {
      background-color: #374151;
    }

    #resizer:hover {
      background-color: var(--sl-color-primary-200);
    }

    @media (max-width: 768px) {
      .app-container {
        --sidebar-width: 0px;
      }

      #resizer {
        display: none;
      }

      #sidebar {
        display: none;
      }

      #main-container {
        overflow-x: hidden;
      }

      body {
        overflow-x: hidden;
      }
    }


    @media (max-width: 400px) {
      .app-container {
        min-width: 0;
        width: 100%;
      }

      main {
        min-width: 0;
        width: 100%;
      }

      header {
        padding: 0.75rem;
      }

      .flex.items-center.space-x-3 {
        gap: 0.5rem;
      }

      .flex.items-center.space-x-2 {
        gap: 0.25rem;
      }

      #current-feed-title {
        max-width: 120px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      /* Mobile header layout optimizations for 360px */
      header .flex.items-center.justify-between.mb-4 {
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      header .flex.items-center.space-x-3 {
        flex: 1;
        min-width: 0;
      }

      header .flex.items-center.space-x-2 {
        flex-shrink: 0;
      }

      /* Second header row optimizations */
      header .flex.items-center.justify-between:last-child {
        gap: 0.5rem;
        align-items: center;
      }

      /* Tab group responsive sizing */
      #article-filter-tabs {
        flex: 1;
        min-width: 0;
      }

      #article-filter-tabs sl-tab {
        font-size: 0.875rem;
        padding: 0.25rem 0.5rem;
      }

      /* Read All button mobile optimization */
      #mark-all-read-btn {
        flex-shrink: 0;
        font-size: 1.25rem !important;
        width: 2rem;
        height: 2rem;
        min-width: 2rem;
      }

      /* Help button mobile sizing */
      #help-btn {
        font-size: 1rem !important;
        width: 1.75rem;
        height: 1.75rem;
        min-width: 1.75rem;
      }

      /* Theme dropdown button mobile sizing */
      sl-dropdown sl-icon-button {
        font-size: 1rem !important;
        width: 1.75rem;
        height: 1.75rem;
        min-width: 1.75rem;
      }

      /* Menu button mobile sizing */
      #menu-btn {
        font-size: 1.25rem !important;
        width: 2rem;
        height: 2rem;
        min-width: 2rem;
      }
    }

    /* Additional breakpoint for very narrow screens (360px and below) */
    @media (max-width: 360px) {
      header {
        padding: 0.5rem;
      }

      #current-feed-title {
        max-width: 100px;
      }

      /* Further compress tab text on very narrow screens */
      #article-filter-tabs sl-tab {
        font-size: 0.75rem;
        padding: 0.25rem 0.375rem;
      }

      /* Ensure Read All button remains visible */
      #mark-all-read-btn {
        font-size: 1.125rem !important;
        width: 1.875rem;
        height: 1.875rem;
        min-width: 1.875rem;
      }

      /* Compact other controls further */
      #help-btn, sl-dropdown sl-icon-button {
        font-size: 0.875rem !important;
        width: 1.5rem;
        height: 1.5rem;
        min-width: 1.5rem;
      }

      /* Reduce gaps further */
      header .flex.items-center.space-x-3 {
        gap: 0.375rem;
      }

      header .flex.items-center.space-x-2 {
        gap: 0.125rem;
      }

      header .flex.items-center.justify-between:last-child {
        gap: 0.375rem;
      }
    }
    

    /* Mobile drawer header styling */
    #mobile-sidebar-drawer::part(header) {
      display: none;
    }

    /* Toast notification positioning */
    .sl-toast-stack {
      left: 50%;
      transform: translateX(-50%);
      right: auto;
      top: var(--sl-spacing-medium);
    }

    #global-loader {
      transition: opacity 0.3s ease-in-out;
    }

    sl-tab sl-badge {
      margin-left: var(--sl-spacing-x-small);
    }

    .bookmark-btn {
      transition: color 0.2s ease;
    }

    .bookmark-btn:hover {
      color: #fbbf24 !important;
      transform: scale(1.1);
    }

    .article-item.new-article {
      border-left: 4px solid #ef4444;
    }

    /* ëŒ“ê¸€ ë‚´ìš© ìŠ¤íƒ€ì¼ë§ */
    .comment-content ul,
    .comment-content ol {
      padding-left: 1.5em;
      margin-bottom: 1em;
      margin-top: 0.5em;
    }

    .comment-content ul {
      list-style-type: disc;
    }

    .comment-content ol {
      list-style-type: decimal;
    }

    .comment-content ul ul {
      list-style-type: circle;
      margin-top: 0.25em;
      margin-bottom: 0.25em;
    }

    .comment-content ol ol {
      list-style-type: lower-alpha;
      margin-top: 0.25em;
      margin-bottom: 0.25em;
    }

    .comment-content li {
      margin-bottom: 0.5em;
      line-height: 1.6;
      padding-left: 0.25em;
    }

    .comment-content li>p {
      margin-bottom: 0.5em;
    }

    .comment-content li:last-child {
      margin-bottom: 0;
    }

    .comment-content a {
      color: var(--sl-color-primary-600);
      text-decoration: underline;
    }

    .comment-content code {
      background-color: #f3f4f6;
      color: #1f2937;
      padding: 0.125rem 0.25rem;
      border-radius: 0.25rem;
      font-size: 0.875em;
      font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
    }

    .dark .comment-content code {
      background-color: #374151;
      color: #e5e7eb;
    }

    .comment-content h6 {
      font-size: 1em;
      font-weight: 600;
      margin-bottom: 0.5em;
      margin-top: 1em;
    }

    .comment-content h6:first-child {
      margin-top: 0;
    }

    .comment-content p {
      margin-bottom: 0.75em;
      line-height: 1.6;
    }

    /* Text wrapping fixes for long content */
    #detail-content,
    #detail-content p,
    .article-item h3,
    .comment-content,
    #feed-list sl-menu-item span,
    #current-feed-title {
      word-break: break-word;
      word-wrap: break-word;
      overflow-wrap: anywhere;
    }

    /* Preserve code block formatting */
    #detail-content pre,
    #detail-content code,
    .comment-content pre,
    .comment-content code {
      word-break: normal;
      word-wrap: normal;
      overflow-wrap: normal;
      white-space: pre-wrap;
    }

    /* Search result card styles */
    .search-result-card {
      transition: all 0.2s ease;
    }
    
    .search-result-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
    }
    
    .dark .search-result-card:hover {
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    }
    
    .search-highlight {
      background-color: #fef3c7;
      color: #92400e;
      padding: 0.125rem 0.25rem;
      border-radius: 0.25rem;
      font-weight: 500;
    }
    
    .dark .search-highlight {
      background-color: #374151;
      color: #fbbf24;
    }
    
    .content-preview {
      display: -webkit-box;
      -webkit-line-clamp: 3;
      -webkit-box-orient: vertical;
      overflow: hidden;
      line-height: 1.5;
    }
    
    /* Relative time styling */
    .relative-time {
      cursor: help;
      border-bottom: 1px dotted currentColor;
      transition: border-bottom-color 0.2s ease;
    }
    
    .relative-time:hover {
      border-bottom-color: transparent;
    }
    
    /* Article card responsive layout */
    .article-card-container {
      width: 100%;
    }
    
    /* Default: hide both layouts */
    .article-desktop-layout {
      display: none;
    }
    
    .article-mobile-layout {
      display: none;
    }
    
    /* Desktop layout (768px and up) */
    @media (min-width: 768px) {
      .article-desktop-layout {
        display: flex !important;
      }
      
      .article-mobile-layout {
        display: none !important;
      }
    }
    
    /* Mobile layout (below 768px) */
    @media (max-width: 767px) {
      .article-desktop-layout {
        display: none !important;
      }
      
      .article-mobile-layout {
        display: block !important;
      }
      
      /* Compact mobile padding */
      .article-item {
        padding: 0.75rem !important;
        margin-bottom: 0.75rem !important;
      }
      
      /* Remove default margins in mobile */
      .article-mobile-layout * {
        margin-block-start: 0;
        margin-block-end: 0;
      }
      
      /* Mobile actions alignment and spacing */
      .article-actions-mobile {
        margin: 0;
        padding: 0;
      }
      
      /* Smaller mobile buttons */
      .article-actions-mobile sl-icon-button {
        font-size: 1rem !important;
        width: 2rem !important;
        height: 2rem !important;
      }
      
      .article-actions-mobile sl-button {
        font-size: 0.75rem !important;
        padding: 0.25rem 0.5rem !important;
        height: auto !important;
        min-height: 1.75rem !important;
      }
      
      /* Better mobile author/date text */
      .article-mobile-layout .text-sm {
        font-size: 0.75rem;
      }
      
      /* Optimize favicon size for mobile */
      .article-mobile-layout img {
        width: 1.5rem !important;
        height: 1.5rem !important;
      }
      
      /* Better mobile spacing */
      .article-mobile-layout .flex.items-start.space-x-3 {
        gap: 0.75rem;
      }
    }
  </style>
</head>

<body class="bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200 antialiased">

  <div id="global-loader" class="fixed inset-0 bg-white dark:bg-gray-900 z-[9999] flex items-center justify-center">
    <sl-spinner style="font-size: 3rem;"></sl-spinner>
  </div>

  <!-- Main App View -->
  <div id="main-container" class="relative min-h-screen">
    <div class="app-container">
      <!-- Sidebar -->
      <aside id="sidebar" class="bg-white dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700 flex flex-col">
        <div class="p-4 border-b dark:border-gray-700">
          <div class="flex items-center justify-between">
            <h1 class="text-xl font-bold text-gray-900 dark:text-gray-100">Feedic <span class="text-xs text-gray-500 dark:text-gray-400 font-normal">v1.1.1</span></h1>
            <sl-icon-button id="mobile-close-btn" name="x-lg" label="Close" class="text-xl md:hidden"></sl-icon-button>
          </div>
        </div>
        <div class="p-4 border-b dark:border-gray-700">
          <form id="add-feed-form" class="flex flex-col space-y-3">
            <sl-textarea id="feed-urls" placeholder="ì—¬ëŸ¬ í”¼ë“œë¥¼ ì¶”ê°€í•˜ë ¤ë©´ í•œ ì¤„ì— í•˜ë‚˜ì”© URLì„ ì…ë ¥í•˜ì„¸ìš”." resize="auto"></sl-textarea>
            <sl-button type="submit" variant="primary" class="w-full">í”¼ë“œ ì¶”ê°€</sl-button>
          </form>
        </div>
        <nav id="feed-list" class="flex-1 overflow-y-auto p-2"></nav>
      </aside>

      <!-- Resizer -->
      <div id="resizer"></div>

      <!-- Main Content -->
      <main class="flex-1 flex flex-col bg-gray-50 dark:bg-gray-900 h-screen">
        <header class="p-4 border-b bg-white dark:bg-gray-800 dark:border-gray-700">
          <div class="flex items-center justify-between mb-4">
            <div class="flex items-center space-x-3">
              <sl-icon-button id="menu-btn" name="list" label="Menu" class="md:hidden text-2xl"></sl-icon-button>
              <div class="flex flex-col">
                <h2 id="current-feed-title" class="text-xl font-semibold truncate text-gray-900 dark:text-gray-100">ëª¨ë“  í”¼ë“œ</h2>
                <span id="last-update-time" class="text-xs text-gray-500 dark:text-gray-400"></span>
              </div>
              <sl-icon-button id="help-btn" name="question-circle" label="Help" class="text-xl"></sl-icon-button>
            </div>
            <div class="flex items-center space-x-2">
              <sl-icon-button id="search-btn" name="search" label="ê²€ìƒ‰" class="text-xl"></sl-icon-button>
              <sl-dropdown>
                <sl-icon-button name="sun" label="Theme" class="text-xl" slot="trigger"></sl-icon-button>
                <sl-menu id="theme-menu">
                  <sl-menu-item value="light">Light <sl-icon name="check" slot="suffix"></sl-icon></sl-menu-item>
                  <sl-menu-item value="dark">Dark <sl-icon name="check" slot="suffix"></sl-icon></sl-menu-item>
                  <sl-menu-item value="system">System <sl-icon name="check" slot="suffix"></sl-icon></sl-menu-item>
                </sl-menu>
              </sl-dropdown>
              <sl-spinner id="loader" class="loader hidden"></sl-spinner>
            </div>
          </div>
          <div class="flex items-center justify-between">
            <sl-tab-group id="article-filter-tabs">
              <sl-tab slot="nav" panel="unread" active>ì½ì§€ ì•ŠìŒ</sl-tab>
              <sl-tab slot="nav" panel="read">ì½ìŒ</sl-tab>
              <sl-tab slot="nav" panel="bookmarked">ë¶ë§ˆí¬</sl-tab>
            </sl-tab-group>
            <sl-icon-button id="mark-all-read-btn" name="check2-all" label="í˜„ì¬ ëª©ë¡ ëª¨ë‘ ì½ìŒìœ¼ë¡œ í‘œì‹œ"
              class="text-2xl"></sl-icon-button>
          </div>
        </header>
        <div id="article-list" class="flex-1 overflow-y-auto p-4 space-y-3">
          <div id="empty-state" class="text-center py-10 text-gray-500">
            <p>í‘œì‹œí•  ê¸°ì‚¬ê°€ ì—†ìŠµë‹ˆë‹¤.</p>
          </div>
        </div>
      </main>
    </div>
  </div>

  <!-- Mobile Sidebar Drawer -->
  <sl-drawer id="mobile-sidebar-drawer" class="md:hidden">
    <div id="mobile-sidebar-content" class="h-full flex flex-col"></div>
  </sl-drawer>

  <!-- Article Detail View -->
  <div id="article-detail-container" class="hidden fixed inset-0 bg-white dark:bg-gray-900 z-50 flex flex-col">
    <header
      class="flex items-center justify-between p-4 border-b dark:border-gray-700 sticky top-0 bg-white/80 dark:bg-gray-900/80 backdrop-blur-sm">
      <sl-icon-button id="detail-back-btn" name="arrow-left" label="Back" class="text-2xl"></sl-icon-button>
      <div class="flex items-center space-x-2">
        <sl-button id="detail-prev-btn" size="small"><sl-icon slot="prefix" name="arrow-left-short"></sl-icon>ì´ì „
          (â†)</sl-button>
        <sl-button id="detail-next-btn" size="small"><sl-icon slot="suffix" name="arrow-right-short"></sl-icon>ë‹¤ìŒ
          (â†’)</sl-button>
      </div>
      <sl-button id="detail-link-btn" href="#" target="_blank" variant="primary" size="small">ì›ë¬¸ ë³´ê¸°</sl-button>
    </header>
    <div id="detail-scroll-container" class="flex-1 overflow-y-auto p-6 md:p-8 lg:p-12">
      <div class="max-w-3xl mx-auto">
        <h1 id="detail-title" class="text-3xl md:text-4xl font-bold mb-2 text-gray-900 dark:text-gray-100"></h1>
        <p id="detail-author" class="text-gray-500 dark:text-gray-400 mb-8"></p>
        <div id="detail-content" class="prose dark:prose-invert lg:prose-xl max-w-none"></div>
      </div>
    </div>
  </div>

  <!-- Search View -->
  <div id="search-container" class="hidden fixed inset-0 bg-gray-50 dark:bg-gray-900 z-40 flex flex-col">
    <header class="p-4 border-b bg-white dark:bg-gray-800 dark:border-gray-700 sticky top-0">
      <div class="flex items-center justify-between mb-4">
        <div class="flex items-center space-x-3">
          <sl-icon-button id="search-back-btn" name="arrow-left" label="Back" class="text-2xl"></sl-icon-button>
          <h2 class="text-xl font-semibold text-gray-900 dark:text-gray-100">ê²€ìƒ‰</h2>
        </div>
        <div class="flex items-center space-x-2">
          <sl-dropdown>
            <sl-icon-button name="sun" label="Theme" class="text-xl" slot="trigger"></sl-icon-button>
            <sl-menu id="search-theme-menu">
              <sl-menu-item value="light">Light <sl-icon name="check" slot="suffix"></sl-icon></sl-menu-item>
              <sl-menu-item value="dark">Dark <sl-icon name="check" slot="suffix"></sl-icon></sl-menu-item>
              <sl-menu-item value="system">System <sl-icon name="check" slot="suffix"></sl-icon></sl-menu-item>
            </sl-menu>
          </sl-dropdown>
        </div>
      </div>
      <div class="max-w-2xl mx-auto">
        <div class="flex gap-2">
          <sl-input 
            id="search-input" 
            placeholder="ê¸°ì‚¬ ì œëª©, ë‚´ìš© ê²€ìƒ‰..." 
            clearable
            size="large"
            class="flex-1"
          >
            <sl-icon name="search" slot="prefix"></sl-icon>
          </sl-input>
          <sl-button id="perform-search-btn" variant="primary" size="large">
            ê²€ìƒ‰
          </sl-button>
        </div>
      </div>
    </header>
    <div class="flex-1 overflow-y-auto">
      <div class="max-w-4xl mx-auto p-6">
        <div id="search-stats" class="text-sm text-gray-500 dark:text-gray-400 mb-4 hidden">
          "<span id="search-term"></span>" ê²€ìƒ‰ ê²°ê³¼: <span id="search-count">0</span>ê°œ
        </div>
        <div id="search-results" class="space-y-4">
          <div id="search-empty-state" class="text-center py-20 text-gray-500 dark:text-gray-400">
            <sl-icon name="search" class="text-6xl mb-4 opacity-50"></sl-icon>
            <p class="text-lg">ë‚´ ê¸°ì‚¬ì—ì„œ ê²€ìƒ‰í•´ë³´ì„¸ìš”</p>
            <p class="text-sm mt-2">ì œëª©ê³¼ ë‚´ìš©ì—ì„œ ê²€ìƒ‰í•©ë‹ˆë‹¤</p>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Help Modal -->
  <sl-dialog id="help-modal" label="í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤">
    <ul class="space-y-4 text-gray-700 dark:text-gray-300">
      <li class="flex items-center"><kbd
          class="font-mono text-sm font-semibold text-gray-900 bg-gray-200 rounded-md px-2 py-1 mr-4">â†‘</kbd> / <kbd
          class="font-mono text-sm font-semibold text-gray-900 bg-gray-200 rounded-md px-2 py-1 mx-2">â†“</kbd><span>ê¸°ì‚¬
          ëª©ë¡ì—ì„œ ì´ë™ / ìƒì„¸ ë³´ê¸°ì—ì„œ ìŠ¤í¬ë¡¤</span></li>
      <li class="flex items-center"><kbd
          class="font-mono text-sm font-semibold text-gray-900 bg-gray-200 rounded-md px-2 py-1 mr-4">â†</kbd> / <kbd
          class="font-mono text-sm font-semibold text-gray-900 bg-gray-200 rounded-md px-2 py-1 mx-2">â†’</kbd><span>ìƒì„¸
          ë³´ê¸°ì—ì„œ ì´ì „/ë‹¤ìŒ ê¸°ì‚¬ë¡œ ì´ë™</span></li>
      <li class="flex items-center"><kbd
          class="font-mono text-sm font-semibold text-gray-900 bg-gray-200 rounded-md px-3 py-1 mr-4">Space</kbd><span>ì„ íƒí•œ
          ê¸°ì‚¬ ìƒì„¸ ë³´ê¸°</span></li>
      <li class="flex items-center"><kbd
          class="font-mono text-sm font-semibold text-gray-900 bg-gray-200 rounded-md px-2 py-1 mr-4">âŒ«</kbd><span>ìƒì„¸
          ë³´ê¸°ì—ì„œ ëª©ë¡ìœ¼ë¡œ ëŒì•„ê°€ê¸° / ë„ì›€ë§ ë‹«ê¸°</span></li>
    </ul>
    <sl-button slot="footer" variant="primary" onclick="document.getElementById('help-modal').hide()">ë‹«ê¸°</sl-button>
  </sl-dialog>

  <script>
    const DB_NAME = 'RSSReaderDB', DB_VERSION = 1, FEED_STORE = 'feeds', ARTICLE_STORE = 'articles';
    let db;

    // DB, Feed, Article management functions (unchanged)
    function initDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = (e) => reject("Database error: " + e.target.errorCode);
        request.onsuccess = (e) => { db = e.target.result; resolve(db); };
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains(FEED_STORE)) db.createObjectStore(FEED_STORE, { keyPath: 'url' });
          if (!db.objectStoreNames.contains(ARTICLE_STORE)) {
            const store = db.createObjectStore(ARTICLE_STORE, { keyPath: 'guid' });
            store.createIndex('feedUrl', 'feedUrl', { unique: false });
            store.createIndex('pubDate', 'pubDate', { unique: false });
            store.createIndex('bookmarked', 'bookmarked', { unique: false });
          }
        };
      });
    }
    const getAllFeeds = () => new Promise((resolve) => db.transaction([FEED_STORE]).objectStore(FEED_STORE).getAll().onsuccess = (e) => resolve(e.target.result));
    const deleteFeed = (url) => new Promise((resolve) => {
      const tx = db.transaction([FEED_STORE, ARTICLE_STORE], 'readwrite');
      tx.objectStore(FEED_STORE).delete(url);
      tx.objectStore(ARTICLE_STORE).index('feedUrl').openCursor(IDBKeyRange.only(url)).onsuccess = (e) => {
        const cursor = e.target.result; if (cursor) { cursor.delete(); cursor.continue(); }
      };
      tx.oncomplete = () => resolve();
    });
    async function saveArticles(articles) {
      if (!articles || articles.length === 0) return { hasNewArticles: false, newArticles: [] };
      let hasNewArticles = false;
      let newArticles = [];
      return new Promise((resolve) => {
        const tx = db.transaction([ARTICLE_STORE], 'readwrite');
        const store = tx.objectStore(ARTICLE_STORE);
        const guids = articles.map(a => a.guid);
        const existingArticles = new Map();
        store.openCursor().onsuccess = e => {
          const cursor = e.target.result;
          if (cursor) {
            if (guids.includes(cursor.key)) existingArticles.set(cursor.key, cursor.value);
            cursor.continue();
          } else {
            articles.forEach(newArticle => {
              const existing = existingArticles.get(newArticle.guid);
              if (!existing) {
                hasNewArticles = true;
                newArticles.push(newArticle);
              }
              store.put({ ...newArticle, read: existing ? existing.read : false, bookmarked: existing ? existing.bookmarked : false });
            });
          }
        };
        tx.oncomplete = () => resolve({ hasNewArticles, newArticles });
      });
    }
    const getArticles = (feedUrl = null) => new Promise((resolve) => {
      const store = db.transaction([ARTICLE_STORE]).objectStore(ARTICLE_STORE);
      const req = feedUrl ? store.index('feedUrl').getAll(feedUrl) : store.getAll();
      req.onsuccess = () => resolve(req.result.sort((a, b) => new Date(b.pubDate) - new Date(a.pubDate)));
    });
    const getArticleByGuid = (guid) => new Promise((resolve) => db.transaction([ARTICLE_STORE]).objectStore(ARTICLE_STORE).get(guid).onsuccess = (e) => resolve(e.target.result));
    const setArticleReadStatus = (guid, read) => new Promise((resolve) => {
      const store = db.transaction([ARTICLE_STORE], 'readwrite').objectStore(ARTICLE_STORE);
      store.get(guid).onsuccess = e => {
        const article = e.target.result;
        if (article) { article.read = read; store.put(article).onsuccess = () => resolve(article.read); }
      };
    });

    const setArticleBookmarkStatus = (guid, bookmarked) => new Promise((resolve) => {
      const store = db.transaction([ARTICLE_STORE], 'readwrite').objectStore(ARTICLE_STORE);
      store.get(guid).onsuccess = e => {
        const article = e.target.result;
        if (article) { 
          article.bookmarked = bookmarked; 
          store.put(article).onsuccess = () => resolve(article.bookmarked); 
        }
      };
    });

    // Clean up old articles that are not bookmarked
    const cleanOldArticles = (days = 7) => new Promise((resolve) => {
      const cutoffDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
      const tx = db.transaction([ARTICLE_STORE], 'readwrite');
      const store = tx.objectStore(ARTICLE_STORE);
      let deletedCount = 0;
      
      // Use cursor to iterate through all articles
      store.openCursor().onsuccess = e => {
        const cursor = e.target.result;
        if (cursor) {
          const article = cursor.value;
          const articleDate = new Date(article.pubDate);
          
          // Delete if article is older than cutoff AND not bookmarked
          if (articleDate < cutoffDate && !article.bookmarked) {
            cursor.delete();
            deletedCount++;
          }
          cursor.continue();
        } else {
          // Cursor finished, resolve with deleted count
          resolve(deletedCount);
        }
      };
      
      tx.onerror = () => {
        console.error('Error during cleanup transaction');
        resolve(0);
      };
    });

    // Format relative time using date-fns
    function formatRelativeTime(dateString) {
      try {
        const date = new Date(dateString);
        const now = new Date();
        
        // Use date-fns v2 formatDistanceToNow with Korean locale
        if (typeof dateFns !== 'undefined' && dateFns.formatDistanceToNow && dateFns.ko) {
          return dateFns.formatDistanceToNow(date, { 
            addSuffix: true, 
            locale: dateFns.ko 
          });
        } else {
          // Fallback to manual calculation if date-fns is not available
          const diffMs = now - date;
          const diffMins = Math.floor(diffMs / (1000 * 60));
          const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
          const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
          
          if (diffMins < 1) return 'ë°©ê¸ˆ ì „';
          if (diffMins < 60) return `${diffMins}ë¶„ ì „`;
          if (diffHours < 24) return `${diffHours}ì‹œê°„ ì „`;
          if (diffDays < 7) return `${diffDays}ì¼ ì „`;
          if (diffDays < 30) return `${Math.floor(diffDays / 7)}ì£¼ ì „`;
          if (diffDays < 365) return `${Math.floor(diffDays / 30)}ê°œì›” ì „`;
          return `${Math.floor(diffDays / 365)}ë…„ ì „`;
        }
      } catch (error) {
        console.error('Error formatting relative time:', error);
        return new Date(dateString).toLocaleDateString('ko-KR');
      }
    }

    function updateLastUpdateTime() {
      const lastUpdateEl = document.getElementById('last-update-time');
      if (lastUpdateTime) {
        const now = new Date();
        const diffMs = now - lastUpdateTime;
        const diffMins = Math.floor(diffMs / (1000 * 60));
        const diffHours = Math.floor(diffMs / (1000 * 60 * 60));

        let timeText = '';
        if (diffMins < 1) {
          timeText = 'ë°©ê¸ˆ ì—…ë°ì´íŠ¸';
        } else if (diffMins < 60) {
          timeText = `${diffMins}ë¶„ ì „ ì—…ë°ì´íŠ¸`;
        } else if (diffHours < 24) {
          timeText = `${diffHours}ì‹œê°„ ì „ ì—…ë°ì´íŠ¸`;
        } else {
          timeText = lastUpdateTime.toLocaleString('ko-KR', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' }) + ' ì—…ë°ì´íŠ¸';
        }
        lastUpdateEl.textContent = timeText;
      }
    }

    // Update relative times for all articles every minute
    function updateAllRelativeTimes() {
      const relativeTimeElements = document.querySelectorAll('.relative-time');
      relativeTimeElements.forEach(element => {
        const absoluteDate = element.getAttribute('title');
        if (absoluteDate) {
          // Extract the ISO date from the localized string if needed
          try {
            // Find the associated article element to get the original pubDate
            const articleItem = element.closest('.article-item, .search-result-card');
            if (articleItem) {
              const guid = articleItem.dataset.guid;
              if (guid) {
                // Find the article in current visible articles or search through all
                const foundArticle = currentVisibleArticles.find(a => a.guid === guid);
                if (foundArticle) {
                  element.textContent = formatRelativeTime(foundArticle.pubDate);
                }
              }
            }
          } catch (error) {
            console.error('Error updating relative time:', error);
          }
        }
      });
    }

    // Update time displays every minute
    setInterval(() => {
      updateLastUpdateTime();
      updateAllRelativeTimes();
    }, 60000);

    // UI elements
    const feedListEl = document.getElementById('feed-list'), articleListEl = document.getElementById('article-list');
    const currentFeedTitleEl = document.getElementById('current-feed-title'), emptyStateEl = document.getElementById('empty-state');
    let currentFilter = null, articleFilter = 'unread', currentVisibleArticles = [], lastFocusedArticleGuid = null;
    let newArticleGuids = new Set();
    let lastUpdateTime = null;

    async function renderFeeds() {
      const feeds = await getAllFeeds();
      const feedListHTML = `
                <sl-menu>
                    ${feeds.map(feed => `
                        <sl-menu-item data-url="${feed.url}" class="${currentFilter === feed.url ? 'active' : ''}">
                            <div class="w-full flex justify-between items-center">
                                <span class="truncate pr-2">${feed.title || feed.url}</span>
                                <sl-icon-button name="x-lg" label="Delete" class="delete-feed-btn text-lg" data-url="${feed.url}"></sl-icon-button>
                            </div>
                        </sl-menu-item>
                    `).join('')}
                </sl-menu>
            `;
      feedListEl.innerHTML = feedListHTML;
      document.getElementById('mobile-sidebar-content').innerHTML = document.querySelector('#sidebar').innerHTML;
    }

    // ëŒ“ê¸€ ê°œìˆ˜ë¥¼ ë¹ ë¥´ê²Œ í™•ì¸í•˜ëŠ” í•¨ìˆ˜ (ê°œì„ ëœ ìºì‹±)
    const commentCountCache = new Map();
    const COMMENT_CACHE_DURATION = 30 * 60 * 1000; // 30ë¶„ ìºì‹œ
    
    async function getCommentCount(url) {
      const cacheKey = url;
      const cached = commentCountCache.get(cacheKey);
      
      // ìºì‹œëœ ë°ì´í„°ê°€ ìˆê³  ì•„ì§ ìœ íš¨í•œ ê²½ìš°
      if (cached && (Date.now() - cached.timestamp) < COMMENT_CACHE_DURATION) {
        return cached.count;
      }

      // news.hada.ioë‚˜ clien.netë§Œ ì§€ì›
      if (!url.includes('news.hada.io') && !url.includes('clien.net')) {
        const result = { count: 0, timestamp: Date.now() };
        commentCountCache.set(cacheKey, result);
        return 0;
      }

      try {
        const comments = await fetchComments(url);
        const count = comments ? comments.length : 0;
        const result = { count, timestamp: Date.now() };
        commentCountCache.set(cacheKey, result);
        return count;
      } catch (error) {
        console.error('Error getting comment count:', error);
        const result = { count: 0, timestamp: Date.now() };
        commentCountCache.set(cacheKey, result);
        return 0;
      }
    }

    async function renderArticles(feedUrl = null) {
      const allArticles = await getArticles(feedUrl);
      const feeds = await getAllFeeds();
      const feedsMap = new Map(feeds.map(f => [f.url, f]));

      // Update tab counts
      const unreadCount = allArticles.filter(a => !a.read).length;
      const readCount = allArticles.filter(a => a.read).length;
      const bookmarkedCount = allArticles.filter(a => a.bookmarked).length;
      document.querySelector('sl-tab[panel="unread"]').innerHTML = `ì½ì§€ ì•ŠìŒ <sl-badge pill>${unreadCount}</sl-badge>`;
      document.querySelector('sl-tab[panel="read"]').innerHTML = `ì½ìŒ <sl-badge pill>${readCount}</sl-badge>`;
      document.querySelector('sl-tab[panel="bookmarked"]').innerHTML = `ë¶ë§ˆí¬ <sl-badge pill>${bookmarkedCount}</sl-badge>`;

      if (articleFilter === 'unread') currentVisibleArticles = allArticles.filter(a => !a.read);
      else if (articleFilter === 'read') currentVisibleArticles = allArticles.filter(a => a.read);
      else if (articleFilter === 'bookmarked') currentVisibleArticles = allArticles.filter(a => a.bookmarked);
      else currentVisibleArticles = allArticles.filter(a => !a.read); // Default to unread

      articleListEl.innerHTML = '';
      emptyStateEl.classList.toggle('hidden', currentVisibleArticles.length > 0);
      document.getElementById('mark-all-read-btn').style.display = (articleFilter !== 'read' && currentVisibleArticles.length > 0) ? 'block' : 'none';

      // ê¸°ë³¸ ì•„ì´í…œ ë Œë”ë§ ë¨¼ì € (ëŒ“ê¸€ ì—†ì´)
      currentVisibleArticles.forEach((article, index) => {
        const feed = feedsMap.get(article.feedUrl);
        const faviconUrl = feed ? feed.faviconUrl : '';
        const articleEl = document.createElement('div');
        const newArticleClass = newArticleGuids.has(article.guid) ? 'new-article' : '';
        articleEl.className = `article-item group bg-white dark:bg-gray-800 p-4 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 cursor-pointer ${article.read ? 'read' : ''} ${newArticleClass}`;
        articleEl.dataset.guid = article.guid;
        articleEl.setAttribute('tabindex', '0'); // Make focusable
        const relativeTime = formatRelativeTime(article.pubDate);
        const absoluteDate = new Date(article.pubDate).toLocaleString('ko-KR');

        articleEl.innerHTML = `
                    <div class="article-card-container">
                        <!-- Desktop layout: horizontal -->
                        <div class="article-desktop-layout flex items-start space-x-4">
                            <img src="${faviconUrl}" onerror="this.src='https://placehold.co/32x32/e2e8f0/64748b?text=RSS'; this.onerror=null;" class="w-8 h-8 rounded-full bg-gray-200 flex-shrink-0" alt="í”¼ë“œ ì•„ì´ì½˜">
                            <div class="flex-1 min-w-0">
                                <div class="flex items-start">
                                    <div class="flex-1 min-w-0">
                                        <h3 class="text-lg font-bold text-blue-800 dark:text-blue-400 group-hover:underline">${article.title}</h3>
                                        <div class="flex items-center mt-1">
                                            <p class="text-sm text-gray-500 dark:text-gray-400">
                                                ${article.author || 'ì €ì ì—†ìŒ'} &middot; 
                                                <span class="relative-time" title="${absoluteDate}">${relativeTime}</span>
                                            </p>
                                            <div class="comment-badge-container ml-2" data-url="${article.link}"></div>
                                        </div>
                                    </div>
                                    <div class="article-actions-desktop flex items-center space-x-2 ml-4">
                                        <sl-icon-button name="${article.bookmarked ? 'star-fill' : 'star'}" label="ë¶ë§ˆí¬" class="bookmark-btn text-xl ${article.bookmarked ? 'text-yellow-500' : 'text-gray-400'}" data-guid="${article.guid}"></sl-icon-button>
                                        <sl-button variant="${article.read ? 'default' : 'primary'}" size="small" pill class="toggle-read-btn">${article.read ? 'ì•ˆ ì½ìŒ' : 'ì½ìŒ'}</sl-button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Mobile layout: vertical stack -->
                        <div class="article-mobile-layout">
                            <div class="flex items-start gap-3 mb-2">
                                <img src="${faviconUrl}" onerror="this.src='https://placehold.co/32x32/e2e8f0/64748b?text=RSS'; this.onerror=null;" class="w-6 h-6 rounded-full bg-gray-200 flex-shrink-0 mt-0.5" alt="í”¼ë“œ ì•„ì´ì½˜">
                                <div class="flex-1 min-w-0">
                                    <h3 class="text-base font-bold text-blue-800 dark:text-blue-400 group-hover:underline leading-tight mb-1">${article.title}</h3>
                                    <div class="flex items-center">
                                        <p class="text-xs text-gray-500 dark:text-gray-400">
                                            ${article.author || 'ì €ì ì—†ìŒ'} &middot; 
                                            <span class="relative-time" title="${absoluteDate}">${relativeTime}</span>
                                        </p>
                                        <div class="comment-badge-container ml-2" data-url="${article.link}"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="article-actions-mobile flex items-center justify-end gap-2">
                                <sl-icon-button name="${article.bookmarked ? 'star-fill' : 'star'}" label="ë¶ë§ˆí¬" class="bookmark-btn ${article.bookmarked ? 'text-yellow-500' : 'text-gray-400'}" data-guid="${article.guid}"></sl-icon-button>
                                <sl-button variant="${article.read ? 'default' : 'primary'}" size="small" pill class="toggle-read-btn">${article.read ? 'ì•ˆ ì½ìŒ' : 'ì½ìŒ'}</sl-button>
                            </div>
                        </div>
                    </div>`;
        articleListEl.appendChild(articleEl);
      });
      
      // ëŒ“ê¸€ ê°œìˆ˜ë¥¼ ë¹„ë™ê¸°ë¡œ ë¡œë”© (ì„±ëŠ¥ í–¥ìƒ)
      loadCommentsAsync(currentVisibleArticles);
    }
    
    // ë¹„ë™ê¸° ëŒ“ê¸€ ë¡œë”© í•¨ìˆ˜ (ì„±ëŠ¥ ê°œì„ )
    async function loadCommentsAsync(articles) {
      // ëŒ“ê¸€ì´ ìˆëŠ” ì‚¬ì´íŠ¸ë§Œ í•„í„°ë§
      const articlesWithComments = articles.filter(article => 
        article.link.includes('news.hada.io') || article.link.includes('clien.net')
      );
      
      // 5ê°œì”© ë°°ì¹˜ë¡œ ì²˜ë¦¬ë¡œ ì„œë²„ ë¶€í•˜ ê°ì†Œ
      for (let i = 0; i < articlesWithComments.length; i += 5) {
        const batch = articlesWithComments.slice(i, i + 5);
        const promises = batch.map(async article => {
          try {
            const count = await getCommentCount(article.link);
            const container = document.querySelector(`[data-url="${CSS.escape(article.link)}"]`);
            if (container && count > 0) {
              container.innerHTML = `<sl-badge variant="neutral" pill class="ml-2">ğŸ’¬ ${count}</sl-badge>`;
            }
          } catch (error) {
            console.error(`Error loading comment for ${article.link}:`, error);
          }
        });
        
        await Promise.all(promises);
        // ê° ë°°ì¹˜ ì‚¬ì´ì— ì§§ì€ ì§€ì—° (ë¸Œë¼ìš°ì € ë¸”ë¡ ë°©ì§€)
        if (i + 5 < articlesWithComments.length) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }
    }

    // Feed parsing and syncing functions
    const loaderEl = document.getElementById('loader');
    async function fetchAndSaveFeed(feedUrl) {
      const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(feedUrl)}`;
      try {
        const response = await fetch(proxyUrl);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const xmlText = await response.text();

        const doc = new DOMParser().parseFromString(xmlText, 'application/xml');
        const parseError = doc.querySelector('parsererror');
        if (parseError) {
          console.error('XML Parsing Error:', parseError.textContent);
          throw new Error('ìœ íš¨í•˜ì§€ ì•Šì€ RSS í”¼ë“œ í˜•ì‹ì…ë‹ˆë‹¤.');
        }

        const feedTitle = doc.querySelector('channel > title')?.textContent || doc.querySelector('feed > title')?.textContent || 'Untitled Feed';
        const originalSiteLink = doc.querySelector('channel > link:not([rel])')?.textContent.trim() || doc.querySelector('feed > link[rel="alternate"]')?.getAttribute('href') || feedUrl;

        const items = Array.from(doc.querySelectorAll('item, entry'));
        const articles = items.map(item => {
          const title = item.querySelector('title')?.textContent || '[No Title]';
          const linkElement = item.querySelector('link');
          const link = linkElement?.getAttribute('href') || linkElement?.textContent.trim() || '';
          const guid = item.querySelector('guid')?.textContent || item.querySelector('id')?.textContent || link;
          const pubDate = item.querySelector('pubDate, published, updated')?.textContent || new Date().toISOString();
          const author = item.querySelector('author > name, creator')?.textContent || '';
          const content = item.querySelector('*|content, content')?.textContent || item.querySelector('description, summary')?.textContent || '';

          return { guid, title, link, author, pubDate: new Date(pubDate).toISOString(), content, feedUrl };
        });


        let faviconUrl = '';
        try {
          const domain = new URL(originalSiteLink).origin;
          faviconUrl = `https://www.google.com/s2/favicons?sz=32&domain_url=${domain}`;
        } catch (e) { console.warn("Could not determine domain for favicon for feed:", feedUrl); }

        await new Promise((resolve, reject) => {
          const tx = db.transaction([FEED_STORE], 'readwrite');
          const store = tx.objectStore(FEED_STORE);
          const feedData = { url: feedUrl, faviconUrl: faviconUrl, title: feedTitle };
          store.put(feedData);
          tx.oncomplete = () => resolve();
          tx.onerror = (e) => reject(e.target.error);
        });

        const result = await saveArticles(articles);
        const newArticles = result.newArticles || [];
        const newArticlesAdded = result.hasNewArticles || false;

        // Track new article GUIDs for visual separator
        newArticles.forEach(article => newArticleGuids.add(article.guid));

        return { feedTitle, newArticlesAdded, newArticleCount: newArticles.length };
      } catch (error) {
        console.error(`'${feedUrl}' í”¼ë“œ ê°€ì ¸ì˜¤ê¸° ì˜¤ë¥˜:`, error);
        throw error;
      }
    }
    async function refreshAllFeeds() {
      loaderEl.classList.remove('hidden');

      // Clear previous new article markers
      newArticleGuids.clear();

      const feeds = await getAllFeeds();
      const results = await Promise.allSettled(feeds.map(feed => fetchAndSaveFeed(feed.url)));

      let anyNewArticles = false;
      let totalNewArticles = 0;
      results.forEach(result => {
        if (result.status === 'fulfilled' && result.value.newArticlesAdded) {
          anyNewArticles = true;
          totalNewArticles += result.value.newArticleCount || 0;
        }
      });

      loaderEl.classList.add('hidden');
      await renderFeeds();
      await renderArticles(currentFilter);

      // Update last update time
      lastUpdateTime = new Date();
      updateLastUpdateTime();

      // Clean up old articles after adding new ones
      const deletedCount = await cleanOldArticles();
      
      if (anyNewArticles) {
        let message = `ìƒˆë¡œìš´ ê¸°ì‚¬ ${totalNewArticles}ê°œë¥¼ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤.`;
        if (deletedCount > 0) {
          message += ` (ì˜¤ë˜ëœ ê¸°ì‚¬ ${deletedCount}ê°œ ì •ë¦¬)`;
        }
        showMessage(message, 'success');
      } else if (deletedCount > 0) {
        showMessage(`ì˜¤ë˜ëœ ê¸°ì‚¬ ${deletedCount}ê°œë¥¼ ì •ë¦¬í–ˆìŠµë‹ˆë‹¤. ğŸ§¹`, 'info');
      }
    }

    // Event handlers and detail view logic
    const mainContainer = document.getElementById('main-container'), detailContainer = document.getElementById('article-detail-container');
    const showMessage = (message, type = 'error', duration = 3000) => {
      const alert = document.createElement('sl-alert');
      let variant = 'danger';
      let icon = 'exclamation-octagon';
      if (type === 'success') {
        variant = 'success';
        icon = 'check2-circle';
      } else if (type === 'info') {
        variant = 'primary';
        icon = 'info-circle';
      }
      alert.variant = variant;
      alert.duration = duration;
      alert.innerHTML = `<sl-icon name="${icon}" slot="icon"></sl-icon>${message}`;

      alert.addEventListener('click', () => alert.hide());

      document.body.appendChild(alert);
      alert.toast();
    };

    async function fetchComments(url) {
      // news.hada.io ëŒ“ê¸€ ê°€ì ¸ì˜¤ê¸°
      if (url.includes('news.hada.io')) {
        try {
          const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
          const response = await fetch(proxyUrl);
          if (!response.ok) throw new Error('Network response was not ok.');
          const html = await response.text();

          const doc = new DOMParser().parseFromString(html, 'text/html');
          const comments = [];

          // news.hada.ioì˜ ëŒ“ê¸€ êµ¬ì¡° íŒŒì‹±
          let commentElements = [];

          const selectors = [
            'tr[id^="comment_tr_"]',
            '.comment_row',
            '[id^="cid"]',
            '#comment_thread .comment',
            '.comment',
            '[class*="comment"]'
          ];

          for (const selector of selectors) {
            commentElements = doc.querySelectorAll(selector);
            if (commentElements.length > 0) break;
          }

          commentElements.forEach((element, index) => {
            try {
              // ëŒ“ê¸€ ì‘ì„± í¼ì´ë‚˜ ê¸°íƒ€ UI ìš”ì†Œ ì œì™¸
              if (element.querySelector('form.write_comment') ||
                element.querySelector('textarea') ||
                element.querySelector('input[type="submit"]') ||
                element.classList.contains('write_comment') ||
                element.innerHTML.includes('ëŒ“ê¸€ ë‹¬ê¸°') ||
                element.innerHTML.includes('ëŒ“ê¸€ ì ê¸°')) {
                return;
              }

              // ì‘ì„±ì ì •ë³´
              const authorSelectors = ['a[href*="/user?id="]', 'a[href*="/user"]', '.author', '.username'];
              let author = 'ìµëª…';
              let hasValidAuthor = false;

              for (const selector of authorSelectors) {
                const authorEl = element.querySelector(selector);
                if (authorEl && authorEl.textContent.trim() && authorEl.textContent.trim() !== 'ìµëª…') {
                  author = authorEl.textContent.trim();
                  hasValidAuthor = true;
                  break;
                }
              }

              // ì‹œê°„ ì •ë³´
              const timeSelectors = ['.comment_meta', '.meta', '.time', '.date'];
              let timeText = '';
              let hasValidTime = false;

              for (const selector of timeSelectors) {
                const timeEl = element.querySelector(selector);
                if (timeEl) {
                  const textNodes = Array.from(timeEl.childNodes).filter(node => node.nodeType === Node.TEXT_NODE);
                  timeText = textNodes.map(node => node.textContent.trim()).filter(text => text).join(' ');
                  if (timeText && (timeText.includes('ì „') || timeText.includes('ì‹œê°„') || timeText.includes('ì¼'))) {
                    hasValidTime = true;
                    break;
                  }
                }
              }

              // ëŒ“ê¸€ ë‚´ìš©
              const contentSelectors = ['.comment_contents', '.contents', '.content', '.text', '.body'];
              let content = '';
              let htmlContent = '';
              let hasValidContent = false;

              for (const selector of contentSelectors) {
                const contentEl = element.querySelector(selector);
                if (contentEl) {
                  htmlContent = contentEl.innerHTML;
                  content = contentEl.textContent.trim();

                  // í¼ ê´€ë ¨ ë‚´ìš©ì´ë‚˜ ë¹ˆ ë‚´ìš© ì œì™¸
                  if (content &&
                    !content.includes('ëŒ“ê¸€ ë‹¬ê¸°') &&
                    !content.includes('ëŒ“ê¸€ ì ê¸°') &&
                    !content.includes('ì¸ì¦ ì´ë©”ì¼') &&
                    content.length > 10) {
                    hasValidContent = true;
                    break;
                  }
                }
              }

              // ì‹¤ì œ ëŒ“ê¸€ì¸ì§€ ê²€ì¦ (ì‘ì„±ìë‚˜ ì‹œê°„ ì •ë³´ê°€ ìˆê±°ë‚˜, ìœ íš¨í•œ ë‚´ìš©ì´ ìˆëŠ” ê²½ìš°ë§Œ)
              if ((hasValidAuthor || hasValidTime || hasValidContent) &&
                content && content.length > 10) {
                const commentId = element.id || `comment_${index + 1}`;

                comments.push({
                  id: commentId,
                  author: author,
                  time: timeText,
                  content: content,
                  htmlContent: htmlContent
                });
              }
            } catch (error) {
              console.error(`Error parsing comment ${index}:`, error);
            }
          });
          return comments;
        } catch (error) {
          console.error('Error fetching comments:', error);
          return [];
        }
      }

      // clien.net ëŒ“ê¸€ ê°€ì ¸ì˜¤ê¸°
      if (url.includes('clien.net')) {
        try {
          // URLì—ì„œ ê²Œì‹œê¸€ ID ì¶”ì¶œ
          const urlMatch = url.match(/\/([^\/]+)\/(\d+)$/);
          if (!urlMatch) {
            console.log('Could not extract board and post ID from URL:', url);
            return [];
          }

          const boardType = urlMatch[1]; // 'news'
          const postId = urlMatch[2]; // '19048102'

          console.log(`Clien.net: board=${boardType}, postId=${postId}`);

          // ë¨¼ì € ì¼ë°˜ í˜ì´ì§€ ë¡œë“œ ì‹œë„
          const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
          const response = await fetch(proxyUrl);
          if (!response.ok) throw new Error('Network response was not ok.');
          const html = await response.text();

          const doc = new DOMParser().parseFromString(html, 'text/html');
          let comments = [];

          // clien.netì˜ ëŒ“ê¸€ êµ¬ì¡° íŒŒì‹± - ì‹¤ì œ êµ¬ì¡° ê¸°ë°˜
          const commentContainer = doc.querySelector('.comment.ad_banner[data-role="comment"]');

          if (!commentContainer) {
            // ë‹¤ë¥¸ ëŒ“ê¸€ ì»¨í…Œì´ë„ˆ selector ì‹œë„
            const alternativeSelectors = ['.comment.ad_banner', '.comment', '#comment-head', '[class*="comment"]'];
            for (const selector of alternativeSelectors) {
              const altContainer = doc.querySelector(selector);
              if (altContainer) {
                break;
              }
            }
          }

          if (commentContainer) {
            // comment_row ìš”ì†Œë“¤ ì°¾ê¸°
            const commentRows = commentContainer.querySelectorAll('.comment_row[data-role="comment-row"]');

            commentRows.forEach((row, index) => {
              try {
                // ë°ì´í„° ì†ì„±ì—ì„œ ì •ë³´ ì¶”ì¶œ
                const authorId = row.getAttribute('data-author-id');
                const commentSn = row.getAttribute('data-comment-sn');
                const isReply = row.classList.contains('re');

                // ë°ì´í„° ì†ì„± íŒŒì‹± ì™„ë£Œ

                // ë‹‰ë„¤ì„ ì¶”ì¶œ
                const nicknameEl = row.querySelector('.nickname');
                let author = authorId || 'í´ë¦¬ì•™ ì‚¬ìš©ì';
                if (nicknameEl && nicknameEl.textContent.trim()) {
                  author = nicknameEl.textContent.trim();
                }

                // ëŒ“ê¸€ ë‚´ìš© ì¶”ì¶œ
                const contentEl = row.querySelector('.comment_view');
                let content = '';
                let htmlContent = '';
                if (contentEl) {
                  content = contentEl.textContent.trim();
                  htmlContent = contentEl.innerHTML;
                } else {
                  // comment_viewê°€ ì—†ìœ¼ë©´ ì „ì²´ í…ìŠ¤íŠ¸ì—ì„œ ì¶”ì¶œ
                  const fullText = row.textContent.trim();
                  const lines = fullText.split('\n').filter(line => line.trim());
                  for (const line of lines) {
                    if (line.length > 5 &&
                      !line.includes('ê³µê°') &&
                      !line.includes('ì‹ ê³ ') &&
                      !line.includes('ëŒ€ëŒ“ê¸€') &&
                      !line.match(/^\d+$/)) {
                      content = line;
                      break;
                    }
                  }
                }

                // ì‹œê°„ ì •ë³´ ì¶”ì¶œ
                const timeEl = row.querySelector('.time, .date, [class*="time"], [class*="date"]');
                let timeText = '';
                if (timeEl) {
                  timeText = timeEl.textContent.trim();
                } else {
                  // í…ìŠ¤íŠ¸ì—ì„œ ì‹œê°„ íŒ¨í„´ ì°¾ê¸°
                  const fullText = row.textContent;
                  const timeMatch = fullText.match(/\d{2}-\d{2}-\d{2}\s+\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}/);
                  if (timeMatch) {
                    timeText = timeMatch[0];
                  }
                }

                // ìœ íš¨í•œ ëŒ“ê¸€ë§Œ ì¶”ê°€
                if (content && content.length > 1) {
                  comments.push({
                    id: commentSn || (index + 1),
                    author: author,
                    time: timeText,
                    content: content,
                    htmlContent: htmlContent || content,
                    isReply: isReply,
                    depth: isReply ? 1 : 0,
                    authorId: authorId
                  });
                  // ëŒ“ê¸€ ì¶”ê°€ ì™„ë£Œ
                }
              } catch (error) {
                console.error(`Error parsing comment row ${index}:`, error);
              }
            });
          }

          // êµ¬ì¡° ê¸°ë°˜ìœ¼ë¡œ ì°¾ì§€ ëª»í•œ ê²½ìš° í…ìŠ¤íŠ¸ ê¸°ë°˜ íŒŒì‹± ì‚¬ìš© (ê°œì„ ë¨)
          if (comments.length === 0) {

            // ë‹¤ì–‘í•œ ëŒ“ê¸€ ì„¹ì…˜ selector ì‹œë„
            const commentSectionSelectors = ['#comment-head', '#comments', '.comments', '[id*="comment"]'];
            let commentSection = null;

            for (const selector of commentSectionSelectors) {
              commentSection = doc.querySelector(selector);
              if (commentSection) {
                break;
              }
            }

            // ì „ì²´ í˜ì´ì§€ì—ì„œ ëŒ“ê¸€ í…ìŠ¤íŠ¸ ì°¾ê¸°
            const textContent = commentSection ? commentSection.textContent : doc.body.textContent;
            const lines = textContent.split('\n').map(line => line.trim()).filter(line => line.length > 0);

            // ëŒ“ê¸€ ID íŒ¨í„´ì´ ìˆëŠ”ì§€ ë¨¼ì € í™•ì¸
            const allText = textContent;
            const commentIdMatches = allText.match(/#\d{9,}/g);

            // ëŒ“ê¸€ ID íŒ¨í„´ìœ¼ë¡œ ëª¨ë“  ëŒ“ê¸€ ì°¾ê¸° (ëŒ€ëŒ“ê¸€ í¬í•¨)
            let currentComment = null;
            let commentCount = 0;
            let collectingContent = false;

            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];

              // ëŒ“ê¸€ ID íŒ¨í„´ (#ìˆ«ì - 8ìë¦¬ ì´ìƒ) ë˜ëŠ” ëŒ€ëŒ“ê¸€ íŒ¨í„´
              const commentIdMatch = line.match(/^#\d{9,}$/) || line.match(/^Re:\s*#\d{9,}$/);
              if (commentIdMatch) {
                if (currentComment && currentComment.content && currentComment.content.length > 5) {
                  comments.push(currentComment);
                  commentCount++;
                }
                const isReply = line.startsWith('Re:');
                currentComment = {
                  id: line,
                  author: 'í´ë¦¬ì•™ ì‚¬ìš©ì',
                  time: '',
                  content: '',
                  isReply: isReply,
                  depth: isReply ? 1 : 0
                };
                collectingContent = false;
              }
              // ë‹‰ë„¤ì„ íŒ¨í„´ (í•œê¸€, ì˜ë¬¸, ìˆ«ì, íŠ¹ìˆ˜ë¬¸ì ì¡°í•©)
              else if (currentComment && !currentComment.authorSet && line.match(/^[ê°€-í£a-zA-Z0-9_\-\[\]()]+$/)) {
                // IPë‚˜ ë‚ ì§œê°€ ì•„ë‹Œ ê²½ìš°ë§Œ ë‹‰ë„¤ì„ìœ¼ë¡œ ì²˜ë¦¬
                if (!line.startsWith('IP') && !line.match(/\d{2}-\d{2}-\d{2}/) && line.length <= 20) {
                  currentComment.author = line;
                  currentComment.authorSet = true;
                }
              }
              // IP ì£¼ì†Œ íŒ¨í„´
              else if (line.startsWith('IP ')) {
                if (currentComment) {
                  currentComment.ip = line;
                  // IP ì´í›„ë¶€í„° ëŒ“ê¸€ ë‚´ìš© ìˆ˜ì§‘ ì‹œì‘
                  collectingContent = true;
                }
              }
              // ë‚ ì§œ/ì‹œê°„ íŒ¨í„´
              else if (line.match(/\d{2}-\d{2}-\d{2}\s+\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}/)) {
                if (currentComment) {
                  currentComment.time = line;
                  collectingContent = true;
                }
              }
              // ì•¡ì…˜ ë¼ì¸ë“¤ ìŠ¤í‚µ
              else if (line.includes('ëŒ€ëŒ“ê¸€') || line.includes('ê³µê°') || line.includes('ì‹ ê³ ') ||
                line === 'LINK' || line.match(/^\d+$/)) {
                continue;
              }
              // ì‹¤ì œ ëŒ“ê¸€ ë‚´ìš© ìˆ˜ì§‘ (ì—¬ëŸ¬ ì¤„ ì§€ì›)
              else if (currentComment && line.length > 3) {
                // ì‹œìŠ¤í…œ ë©”ì‹œì§€ë‚˜ UI í…ìŠ¤íŠ¸ ì œì™¸í•˜ê³  ì‹¤ì œ ëŒ“ê¸€ ë‚´ìš© ì°¾ê¸°
                if (!line.includes('ëŒ€ëŒ“ê¸€') &&
                  !line.includes('ê³µê°') &&
                  !line.includes('ì‹ ê³ ') &&
                  !line.includes('ë“±ë¡') &&
                  !line.includes('ìˆ˜ì •') &&
                  !line.includes('ì‚­ì œ') &&
                  !line.includes('ë¡œê·¸ì¸') &&
                  !line.includes('ìƒˆë¡œê³ ì¹¨') &&
                  !line.includes('ëª©ë¡') &&
                  !line.startsWith('IP ') &&
                  !line.match(/\d{2}-\d{2}-\d{2}/) &&
                  !line.match(/^\d+$/) &&
                  line !== 'LINK' &&
                  !line.match(/^(ì˜ˆ|ì•„ë‹ˆì˜¤|í™•ì¸|ì·¨ì†Œ|ë‹«ê¸°)$/)) {

                  // ì²« ë²ˆì§¸ ë‚´ìš©ì´ê±°ë‚˜ ê¸°ì¡´ ë‚´ìš©ì— ì¶”ê°€
                  if (!currentComment.content) {
                    currentComment.content = line;
                    collectingContent = true;
                  } else if (collectingContent) {
                    // ê¸´ ëŒ“ê¸€ì˜ ì—°ì†ëœ ì¤„ ì¶”ê°€
                    currentComment.content += '\n' + line;
                  }
                }
              }
            }

            // ë§ˆì§€ë§‰ ëŒ“ê¸€ ì¶”ê°€
            if (currentComment && currentComment.content && currentComment.content.length > 5) {
              comments.push(currentComment);
              commentCount++;
            }

            // í…ìŠ¤íŠ¸ ê¸°ë°˜ íŒŒì‹± ì™„ë£Œ

            // HTMLì—ì„œ ëŒ“ê¸€ íŒ¨í„´ ê²€ìƒ‰ ì™„ë£Œ
          }

          // ëŒ“ê¸€ íŒŒì‹± ì™„ë£Œ

          return comments.map((comment, index) => ({
            id: comment.id || index + 1,
            author: comment.author || 'í´ë¦¬ì•™ ì‚¬ìš©ì',
            time: comment.time || '',
            content: comment.content || '',
            htmlContent: comment.htmlContent || comment.content,
            isReply: comment.isReply || false,
            depth: comment.depth || 0,
            authorId: comment.authorId
          }));
        } catch (error) {
          console.error('Error fetching clien.net comments:', error);
          return [];
        }
      }

      // ë‹¤ë¥¸ ì‚¬ì´íŠ¸ëŠ” ë¹ˆ ë°°ì—´ ë°˜í™˜
      return [];
    }

    async function fetchAndDisplayFullContent(url, fallbackContent) {
      const detailContentEl = document.getElementById('detail-content');
      detailContentEl.innerHTML = '<div class="flex justify-center items-center p-8"><sl-spinner class="text-4xl"></sl-spinner></div>';
      try {
        const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
        const response = await fetch(proxyUrl);
        if (!response.ok) throw new Error('Network response was not ok.');
        const html = await response.text();

        const doc = new DOMParser().parseFromString(html, 'text/html');
        doc.baseURI = url;
        const reader = new Readability(doc);
        const article = reader.parse();

        if (article && article.content) {
          detailContentEl.innerHTML = article.content;
        } else {
          throw new Error('Readability could not parse the article.');
        }

        // ëŒ“ê¸€ ê°€ì ¸ì˜¤ê¸° ë° í‘œì‹œ
        const comments = await fetchComments(url);
        if (comments.length > 0) {
          const commentsHtml = `
            <div id="comments-section" class="mt-12 pt-8 border-t dark:border-gray-700">
              <h3 class="text-xl font-bold mb-6 text-gray-900 dark:text-gray-100">ëŒ“ê¸€ ${comments.length}ê°œ</h3>
              <div class="space-y-4">
                ${comments.map(comment => `
                  <div class="${comment.isReply ? 'ml-8 border-l-2 border-blue-200 dark:border-blue-800' : ''} bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
                    <div class="flex items-center justify-between mb-2">
                      <div class="flex items-center">
                        ${comment.isReply ? '<span class="text-blue-500 mr-2">â†³</span>' : ''}
                        <span class="font-semibold text-gray-900 dark:text-gray-100">${comment.author}</span>
                        ${comment.isReply ? '<span class="ml-2 text-xs bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200 px-2 py-1 rounded">ë‹µê¸€</span>' : ''}
                      </div>
                      <span class="text-sm text-gray-500 dark:text-gray-400">${comment.time}</span>
                    </div>
                    <div class="comment-content text-gray-700 dark:text-gray-300">${comment.htmlContent || comment.content}</div>
                  </div>
                `).join('')}
              </div>
            </div>
          `;
          // ëŒ“ê¸€ HTML ì¶”ê°€
          detailContentEl.innerHTML += commentsHtml;
        } else {
          // ëŒ“ê¸€ì´ ì—†ëŠ” ê²½ìš°ì—ë„ ì‚¬ìš©ìì—ê²Œ ì•Œë¦¼ í‘œì‹œ
          if (url.includes('clien.net') || url.includes('news.hada.io')) {
            const noCommentsHtml = `
              <div id="comments-section" class="mt-12 pt-8 border-t dark:border-gray-700">
                <h3 class="text-xl font-bold mb-6 text-gray-900 dark:text-gray-100">ëŒ“ê¸€</h3>
                <div class="bg-gray-50 dark:bg-gray-800 rounded-lg p-4 text-center">
                  <p class="text-gray-600 dark:text-gray-400">
                    ëŒ“ê¸€ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. 
                    <a href="${url}" target="_blank" class="text-blue-600 dark:text-blue-400 hover:underline">
                      ì›ë³¸ í˜ì´ì§€ì—ì„œ í™•ì¸í•˜ê¸°
                    </a>
                  </p>
                </div>
              </div>
            `;
            detailContentEl.innerHTML += noCommentsHtml;
          }
        }

      } catch (error) {
        console.error('Error fetching full content:', error);
        detailContentEl.innerHTML = fallbackContent + '<p class="text-red-500 mt-4">ì „ì²´ ê¸°ì‚¬ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ìš”ì•½ë³¸ì„ í‘œì‹œí•©ë‹ˆë‹¤.</p>';
      } finally {
        detailContentEl.querySelectorAll('pre code').forEach((block) => {
          hljs.highlightElement(block);
        });
      }
    }

    async function updateDetailView(guid) {
      await setArticleReadStatus(guid, true);
      const article = await getArticleByGuid(guid);
      if (!article) return;
      document.getElementById('detail-title').textContent = article.title;
      const relativeTime = formatRelativeTime(article.pubDate);
      const absoluteDate = new Date(article.pubDate).toLocaleString('ko-KR');
      document.getElementById('detail-author').innerHTML = `${article.author || 'ì €ì ì—†ìŒ'} Â· <span class="relative-time" title="${absoluteDate}">${relativeTime}</span>`;
      document.getElementById('detail-link-btn').href = article.link;
      document.getElementById('detail-scroll-container').scrollTop = 0;

      const detailContentEl = document.getElementById('detail-content');
      const MIN_LENGTH_FOR_FULL_CONTENT = 1500;
      if (article.content && article.content.length > MIN_LENGTH_FOR_FULL_CONTENT) {
        detailContentEl.innerHTML = article.content;
        detailContentEl.querySelectorAll('pre code').forEach((block) => {
          hljs.highlightElement(block);
        });
      } else {
        fetchAndDisplayFullContent(article.link, article.content);
      }

      const currentIndex = currentVisibleArticles.findIndex(a => a.guid === guid);
      const prevBtn = document.getElementById('detail-prev-btn'), nextBtn = document.getElementById('detail-next-btn');
      prevBtn.disabled = currentIndex <= 0;
      nextBtn.disabled = currentIndex >= currentVisibleArticles.length - 1;
      prevBtn.dataset.guid = currentIndex > 0 ? currentVisibleArticles[currentIndex - 1].guid : '';
      nextBtn.dataset.guid = currentIndex < currentVisibleArticles.length - 1 ? currentVisibleArticles[currentIndex + 1].guid : '';
    }

    function showDetailView(guid, fromPopState = false) {
      lastFocusedArticleGuid = guid;
      mainContainer.classList.add('hidden');
      detailContainer.classList.remove('hidden');
      updateDetailView(guid);
      if (!fromPopState) {
        history.pushState({ guid: guid }, '', `#detail/${encodeURIComponent(guid)}`);
      }
    }

    function hideDetailView(fromPopState = false) {
      mainContainer.classList.remove('hidden');
      detailContainer.classList.add('hidden');
      renderArticles(currentFilter).then(() => {
        if (lastFocusedArticleGuid) {
          const lastFocusedEl = articleListEl.querySelector(`[data-guid="${lastFocusedArticleGuid}"]`);
          if (lastFocusedEl) {
            lastFocusedEl.focus();
          }
        }
      });
      if (!fromPopState) {
        history.pushState({}, '', window.location.pathname + window.location.search);
      }
    }

    // Use event delegation to handle form submission for both desktop and mobile
    document.body.addEventListener('submit', async (e) => {
      if (e.target.id !== 'add-feed-form') return;
      e.preventDefault();
      const urlsTextarea = e.target.querySelector('#feed-urls');
      const submitButton = e.target.querySelector('sl-button[type="submit"]');
      const urls = urlsTextarea.value.split('\n').map(url => url.trim()).filter(url => url && url.startsWith('http'));

      if (urls.length === 0) {
        showMessage('ìœ íš¨í•œ URLì„ ì…ë ¥í•´ì£¼ì„¸ìš”.', 'error');
        return;
      }

      // ë²„íŠ¼ ë¡œë”© ìƒíƒœ ì‹œì‘
      submitButton.loading = true;
      submitButton.disabled = true;
      loaderEl.classList.remove('hidden');

      const existingFeeds = await getAllFeeds();
      const existingUrls = new Set(existingFeeds.map(f => f.url));
      const newUrls = urls.filter(url => !existingUrls.has(url));

      if (newUrls.length === 0) {
        showMessage('ì…ë ¥ëœ ëª¨ë“  í”¼ë“œê°€ ì´ë¯¸ ì¶”ê°€ë˜ì–´ ìˆìŠµë‹ˆë‹¤.', 'info');
        // ë²„íŠ¼ ë¡œë”© ìƒíƒœ ì¢…ë£Œ
        submitButton.loading = false;
        submitButton.disabled = false;
        loaderEl.classList.add('hidden');
        urlsTextarea.value = '';
        return;
      }

      const results = await Promise.allSettled(newUrls.map(url => fetchAndSaveFeed(url)));

      let successfulCount = 0;
      let failedCount = 0;
      let totalNewArticlesFromFeeds = 0;
      results.forEach(result => {
        if (result.status === 'fulfilled') {
          successfulCount++;
          totalNewArticlesFromFeeds += result.value.newArticleCount || 0;
        }
        else {
          failedCount++;
          console.error('í”¼ë“œ ì¶”ê°€ ì‹¤íŒ¨:', result.reason);
        }
      });

      urlsTextarea.value = '';
      await renderFeeds();
      await renderArticles(currentFilter);

      // ë²„íŠ¼ ë¡œë”© ìƒíƒœ ì¢…ë£Œ
      submitButton.loading = false;
      submitButton.disabled = false;
      loaderEl.classList.add('hidden');

      let message = '';
      if (successfulCount > 0) {
        message += `${successfulCount}ê°œì˜ í”¼ë“œë¥¼ ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.`;
        if (totalNewArticlesFromFeeds > 0) {
          message += ` (ìƒˆ ê¸°ì‚¬ ${totalNewArticlesFromFeeds}ê°œ)`;
        }
        message += ' ';
      }
      if (failedCount > 0) message += `${failedCount}ê°œ ì¶”ê°€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.`;
      const messageType = successfulCount > 0 ? 'success' : 'error';
      showMessage(message.trim(), messageType);

      // Update last update time when adding feeds
      if (successfulCount > 0) {
        lastUpdateTime = new Date();
        updateLastUpdateTime();
      }
    });

    document.body.addEventListener('sl-select', async (e) => {
      const selectedItem = e.detail.item;
      if (selectedItem.closest('#feed-list') || selectedItem.closest('#mobile-sidebar-content')) {
        const url = selectedItem.dataset.url;
        currentFilter = url;

        const feed = (await getAllFeeds()).find(f => f.url === url);
        currentFeedTitleEl.textContent = feed ? (feed.title || url) : 'ê¸°ë³¸ í”¼ë“œ';
        await renderFeeds();
        await renderArticles(currentFilter);

        const drawer = document.getElementById('mobile-sidebar-drawer');
        if (drawer.open) drawer.hide();
      }
    });

    document.body.addEventListener('click', async (e) => {
      const deleteBtn = e.target.closest('.delete-feed-btn');
      if (deleteBtn) {
        e.stopPropagation();
        const url = deleteBtn.dataset.url;
        if (confirm(`'${url}' í”¼ë“œë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
          await deleteFeed(url);
          if (currentFilter === url) { currentFilter = null; currentFeedTitleEl.textContent = 'ëª¨ë“  í”¼ë“œ'; }
          await renderFeeds(); await renderArticles(currentFilter);
        }
      }
    });

    // ë¶ë§ˆí¬ ë²„íŠ¼ í´ë¦­ ì „ìš© ì´ë²¤íŠ¸ ìœ„ì„ í•¸ë“¤ëŸ¬
    articleListEl.addEventListener('click', async (e) => {
      const bookmarkBtn = e.target.closest('.bookmark-btn');
      if (bookmarkBtn) {
        e.preventDefault();
        e.stopPropagation();
        const guid = bookmarkBtn.dataset.guid;
        const article = await getArticleByGuid(guid);
        const nextState = !article.bookmarked;
        await setArticleBookmarkStatus(guid, nextState);
        
        // ê°œë³„ ì•„ì´í…œë§Œ ì—…ë°ì´íŠ¸ (ì„±ëŠ¥ í–¥ìƒ)
        const articleItem = bookmarkBtn.closest('.article-item');
        bookmarkBtn.name = nextState ? 'star-fill' : 'star';
        bookmarkBtn.className = `bookmark-btn text-xl ${nextState ? 'text-yellow-500' : 'text-gray-400'}`;
        
        // ë¶ë§ˆí¬ íƒ­ì˜ ì¹´ìš´íŠ¸ë§Œ ì—…ë°ì´íŠ¸
        const allArticles = await getArticles(currentFilter);
        const bookmarkedCount = allArticles.filter(a => a.bookmarked).length;
        document.querySelector('sl-tab[panel="bookmarked"]').innerHTML = `ë¶ë§ˆí¬ <sl-badge pill>${bookmarkedCount}</sl-badge>`;
        
        // í˜„ì¬ í•„í„°ê°€ ë¶ë§ˆí¬ í•„í„°ì´ê³  ë¶ë§ˆí¬ê°€ í•´ì œëœ ê²½ìš°ì—ë§Œ í•´ë‹¹ ì•„ì´í…œ ì œê±°
        if (articleFilter === 'bookmarked' && !nextState) {
          articleItem.style.transition = 'opacity 0.3s ease';
          articleItem.style.opacity = '0';
          setTimeout(() => {
            articleItem.remove();
            // ë¹ˆ ìƒíƒœ ì²´í¬
            const remainingItems = articleListEl.querySelectorAll('.article-item');
            emptyStateEl.classList.toggle('hidden', remainingItems.length > 0);
          }, 300);
        }
        return;
      }
      
      const articleItem = e.target.closest('.article-item');
      if (!articleItem) return;
      const guid = articleItem.dataset.guid;
      
      if (e.target.closest('.toggle-read-btn')) {
        e.stopPropagation();
        const article = await getArticleByGuid(guid);
        const newReadStatus = !article.read;
        await setArticleReadStatus(guid, newReadStatus);
        
        // ê°œë³„ ì•„ì´í…œ UI ì—…ë°ì´íŠ¸
        const toggleBtn = e.target.closest('.toggle-read-btn');
        const articleItem = e.target.closest('.article-item');
        
        toggleBtn.variant = newReadStatus ? 'default' : 'primary';
        toggleBtn.textContent = newReadStatus ? 'ì•ˆ ì½ìŒ' : 'ì½ìŒ';
        articleItem.classList.toggle('read', newReadStatus);
        
        // íƒ­ ì¹´ìš´íŠ¸ ì—…ë°ì´íŠ¸
        const allArticles = await getArticles(currentFilter);
        const unreadCount = allArticles.filter(a => !a.read).length;
        const readCount = allArticles.filter(a => a.read).length;
        document.querySelector('sl-tab[panel="unread"]').innerHTML = `ì½ì§€ ì•ŠìŒ <sl-badge pill>${unreadCount}</sl-badge>`;
        document.querySelector('sl-tab[panel="read"]').innerHTML = `ì½ìŒ <sl-badge pill>${readCount}</sl-badge>`;
        
        // í˜„ì¬ í•„í„°ì— ë”°ë¥¸ ì•„ì´í…œ ì œê±° ì²˜ë¦¬
        if ((articleFilter === 'unread' && newReadStatus) || (articleFilter === 'read' && !newReadStatus)) {
          articleItem.style.transition = 'opacity 0.3s ease';
          articleItem.style.opacity = '0';
          setTimeout(() => {
            articleItem.remove();
            const remainingItems = articleListEl.querySelectorAll('.article-item');
            emptyStateEl.classList.toggle('hidden', remainingItems.length > 0);
          }, 300);
        }
      } else {
        showDetailView(guid);
      }
    });
    articleListEl.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
        e.preventDefault();
        const items = Array.from(articleListEl.querySelectorAll('.article-item'));
        const currentItem = document.activeElement;
        const currentIndex = items.indexOf(currentItem);

        if (e.key === 'ArrowDown' && currentIndex < items.length - 1) {
          items[currentIndex + 1].focus();
        } else if (e.key === 'ArrowUp' && currentIndex > 0) {
          items[currentIndex - 1].focus();
        }
      } else if (e.key === ' ') {
        e.preventDefault();
        if (document.activeElement.classList.contains('article-item')) {
          document.activeElement.click();
        }
      }
    });

    // í‚¤ë³´ë“œ ì´ë²¤íŠ¸ë¥¼ ì—¬ëŸ¬ ë°©ë²•ìœ¼ë¡œ ì²˜ë¦¬
    function setupKeyboardHandlers() {
      const handlers = [
        { target: document, event: 'keydown' },
        { target: document, event: 'keypress' },
        { target: window, event: 'keydown' },
        { target: document.body, event: 'keydown' }
      ];

      const handleKey = (e) => {
        // ì…ë ¥ í•„ë“œì—ì„œ í‚¤ ì…ë ¥ ì‹œ ë¬´ì‹œ (sl-input ì¸ì§€ë„ í™•ì¸)
        if (e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.closest('sl-input'))) {
          return;
        }

        const helpModal = document.getElementById('help-modal');
        const detailContainer = document.getElementById('article-detail-container');
        const searchContainer = document.getElementById('search-container');
        const isDetailViewVisible = detailContainer && !detailContainer.classList.contains('hidden');
        const isSearchViewVisible = searchContainer && !searchContainer.classList.contains('hidden');

        // í‚¤ë³´ë“œ ì´ë²¤íŠ¸ ì²˜ë¦¬

        if (e.key === 'Backspace') {
          e.preventDefault();
          e.stopPropagation();
          if (helpModal && helpModal.open) {
            helpModal.hide();
          } else if (isDetailViewVisible) {
            hideDetailView();
          }
          return;
        }

        if (isDetailViewVisible) {
          if (e.key === 'ArrowRight') {
            document.getElementById('detail-next-btn').click();
          } else if (e.key === 'ArrowLeft') {
            document.getElementById('detail-prev-btn').click();
          } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
            e.preventDefault();
            const container = document.getElementById('detail-scroll-container');
            const scrollAmount = 120;
            if (e.key === 'ArrowDown') {
              container.scrollBy({ top: scrollAmount, behavior: 'smooth' });
            } else {
              container.scrollBy({ top: -scrollAmount, behavior: 'smooth' });
            }
          }
        }
      };

      handlers.forEach(({ target, event }) => {
        target.addEventListener(event, handleKey, { capture: true });
      });
    }

    // DOM ë¡œë“œ í›„ í•¸ë“¤ëŸ¬ ì„¤ì •
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', setupKeyboardHandlers);
    } else {
      setupKeyboardHandlers();
    }

    document.getElementById('article-filter-tabs').addEventListener('sl-tab-show', (e) => {
      articleFilter = e.detail.name;
      renderArticles(currentFilter);
    });
    document.getElementById('detail-prev-btn').addEventListener('click', (e) => {
      if (!e.currentTarget.disabled) updateDetailView(e.currentTarget.dataset.guid);
    });

    document.getElementById('detail-next-btn').addEventListener('click', (e) => {
      if (!e.currentTarget.disabled) updateDetailView(e.currentTarget.dataset.guid);
    });
    document.getElementById('mark-all-read-btn').addEventListener('click', async () => {
      const articlesToUpdate = currentVisibleArticles.filter(a => !a.read);
      if (articlesToUpdate.length === 0) return;
      const tx = db.transaction([ARTICLE_STORE], 'readwrite');
      articlesToUpdate.forEach(article => { article.read = true; tx.objectStore(ARTICLE_STORE).put(article); });
      tx.oncomplete = async () => renderArticles(currentFilter);
    });

    document.getElementById('detail-back-btn').addEventListener('click', () => history.back());

    // Help Modal Logic
    document.getElementById('help-btn').addEventListener('click', () => document.getElementById('help-modal').show());

    // Mobile Menu Logic
    document.getElementById('menu-btn').addEventListener('click', () => document.getElementById('mobile-sidebar-drawer').show());
    
    // Mobile Close Button Logic - ëª¨ë°”ì¼ ì‚¬ì´ë“œë°”ê°€ ë³µì‚¬ëœ í›„ì— ì´ë²¤íŠ¸ ì¶”ê°€
    document.addEventListener('DOMContentLoaded', () => {
      // ëª¨ë°”ì¼ ë‹«ê¸° ë²„íŠ¼ ì´ë²¤íŠ¸ë¥¼ ìœ„ì„ ë°©ì‹ìœ¼ë¡œ ì²˜ë¦¬
      document.body.addEventListener('click', (e) => {
        if (e.target.closest('#mobile-close-btn')) {
          document.getElementById('mobile-sidebar-drawer').hide();
        }
      });
    });

    // Resizer Logic
    const resizer = document.getElementById('resizer');
    const sidebar = document.getElementById('sidebar');
    resizer.addEventListener('mousedown', function (e) {
      e.preventDefault();
      document.body.style.cursor = 'col-resize';
      document.body.style.userSelect = 'none';

      let animationFrameId = null;
      function onMouseMove(e) {
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
        }
        animationFrameId = requestAnimationFrame(() => {
          const newWidth = e.clientX;
          const containerRect = sidebar.parentElement.getBoundingClientRect();
          const newRelativeWidth = (newWidth - containerRect.left) / containerRect.width * 100;
          document.documentElement.style.setProperty('--sidebar-width', `${newRelativeWidth}%`);
        });
      }

      function onMouseUp() {
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
        localStorage.setItem('sidebarWidth', document.documentElement.style.getPropertyValue('--sidebar-width'));
      }

      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });

    // Router Logic
    window.addEventListener('popstate', (event) => {
      const guid = event.state?.guid;
      if (guid) {
        showDetailView(guid, true);
      } else {
        hideDetailView(true);
      }
    });

    // Search Logic
    let currentSearchTerm = '';
    let searchTimeout;

    function escapeRegExp(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    function highlight(text, term) {
      if (!term) return text;
      const pattern = new RegExp(`(${escapeRegExp(term)})`, 'gi');
      return text.replace(pattern, '<span class="search-highlight">$1</span>');
    }

    async function openSearch() {
      document.getElementById('main-container').classList.add('hidden');
      document.getElementById('article-detail-container').classList.add('hidden');
      document.getElementById('search-container').classList.remove('hidden');
      document.getElementById('search-input').focus();
    }

    function closeSearch() {
      document.getElementById('search-container').classList.add('hidden');
      document.getElementById('main-container').classList.remove('hidden');
      document.getElementById('search-input').value = '';
      currentSearchTerm = '';
      document.getElementById('search-results').innerHTML = '';
      document.getElementById('search-stats').classList.add('hidden');
      document.getElementById('search-empty-state').classList.remove('hidden');
    }

    async function performSearch(term) {
      const searchResultsEl = document.getElementById('search-results');
      const statsEl = document.getElementById('search-stats');
      const countEl = document.getElementById('search-count');
      const termEl = document.getElementById('search-term');
      const emptyEl = document.getElementById('search-empty-state');

      if (!term || term.trim().length === 0) {
        searchResultsEl.innerHTML = '';
        statsEl.classList.add('hidden');
        emptyEl.classList.remove('hidden');
        return;
      }

      const allArticles = await getArticles(currentFilter);
      const lower = term.toLowerCase();
      const results = allArticles.filter(a => {
        const title = a.title || '';
        const contentText = (a.content || '').replace(/<[^>]+>/g, ' ');
        return title.toLowerCase().includes(lower) || contentText.toLowerCase().includes(lower);
      });

      // Render results
      searchResultsEl.innerHTML = results.map(a => {
        const relativeTime = formatRelativeTime(a.pubDate);
        const absoluteDate = new Date(a.pubDate).toLocaleString('ko-KR');
        const contentText = (a.content || '').replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();

        // Find a small excerpt around the first match
        const idx = contentText.toLowerCase().indexOf(lower);
        let excerpt = contentText.slice(0, 240);
        if (idx > 60) {
          const start = Math.max(0, idx - 80);
          excerpt = (start > 0 ? 'â€¦ ' : '') + contentText.slice(start, start + 240);
        }

        return `
          <div class="search-result-card bg-white dark:bg-gray-800 p-4 rounded-lg shadow border border-gray-200 dark:border-gray-700 cursor-pointer" data-guid="${a.guid}">
            <div class="flex items-start space-x-3">
              <div class="flex-1">
                <h3 class="text-lg font-bold text-gray-900 dark:text-gray-100">${highlight(a.title, term)}</h3>
                <p class="text-sm text-gray-500 dark:text-gray-400 mt-1">
                  <span class="relative-time" title="${absoluteDate}">${relativeTime}</span>
                </p>
                <p class="text-sm text-gray-700 dark:text-gray-300 mt-2 content-preview">${highlight(excerpt, term)}</p>
              </div>
              <sl-icon-button name="arrow-right" label="ìƒì„¸ ë³´ê¸°" class="text-lg"></sl-icon-button>
            </div>
          </div>
        `;
      }).join('');

      countEl.textContent = results.length;
      termEl.textContent = term;
      statsEl.classList.remove('hidden');
      emptyEl.classList.toggle('hidden', results.length > 0);
    }

    document.getElementById('search-btn').addEventListener('click', openSearch);
    document.getElementById('search-back-btn').addEventListener('click', closeSearch);
    // ë²„íŠ¼ í´ë¦­ìœ¼ë¡œ ê²€ìƒ‰ ì‹¤í–‰
    document.getElementById('perform-search-btn').addEventListener('click', () => {
      const value = document.getElementById('search-input').value;
      currentSearchTerm = value;
      performSearch(currentSearchTerm);
    });

    // Enter í‚¤ë¡œë„ ê²€ìƒ‰ ì‹¤í–‰
    document.getElementById('search-input').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        const value = e.target.value;
        currentSearchTerm = value;
        performSearch(currentSearchTerm);
      }
    });

    // ê²€ìƒ‰ ê²°ê³¼ í´ë¦­ ì‹œ ìƒì„¸ ë³´ê¸° ì´ë™
    document.getElementById('search-results').addEventListener('click', (e) => {
      const card = e.target.closest('.search-result-card');
      if (!card) return;
      const guid = card.dataset.guid;
      closeSearch();
      showDetailView(guid);
    });

    // ESCë¡œ ê²€ìƒ‰ ë‹«ê¸°
    document.addEventListener('keydown', (e) => {
      const searchOpen = !document.getElementById('search-container').classList.contains('hidden');
      if (searchOpen && e.key === 'Escape') {
        e.preventDefault();
        closeSearch();
      }
    });

    // Theme Logic
    const themeMenu = document.getElementById('theme-menu');
    const searchThemeMenu = document.getElementById('search-theme-menu');
    const themeToggleButton = document.querySelector('sl-dropdown sl-icon-button');
    const html = document.documentElement;

    function applyTheme(theme) {
      const isDark = theme === 'dark' || (theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches);

      html.classList.toggle('dark', isDark);
      html.classList.toggle('sl-theme-dark', isDark);
      themeToggleButton.name = isDark ? 'moon-stars' : 'sun';

      // Update both main and search theme menus
      [themeMenu, searchThemeMenu].forEach(menu => {
        if (menu) {
          menu.querySelectorAll('sl-menu-item').forEach(item => {
            const checkIcon = item.querySelector('sl-icon[slot="suffix"]');
            checkIcon.style.visibility = item.value === theme ? 'visible' : 'hidden';
          });
        }
      });
    }

    // Handle theme selection from both menus
    function handleThemeSelect(event) {
      const theme = event.detail.item.value;
      localStorage.setItem('rss-theme', theme);
      applyTheme(theme);
    }

    themeMenu.addEventListener('sl-select', handleThemeSelect);
    searchThemeMenu.addEventListener('sl-select', handleThemeSelect);

    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
      const currentTheme = localStorage.getItem('rss-theme') || 'system';
      if (currentTheme === 'system') {
        applyTheme('system');
      }
    });

    // 7. ì•± ì‹œì‘
    window.addEventListener('load', async () => {
      const globalLoader = document.getElementById('global-loader');
      try {
        const savedWidth = localStorage.getItem('sidebarWidth');
        if (savedWidth) {
          document.documentElement.style.setProperty('--sidebar-width', savedWidth);
        }

        const savedTheme = localStorage.getItem('rss-theme') || 'system';
        applyTheme(savedTheme);

        await initDB();
        
        // Clean up old articles (7 days old) that are not bookmarked
        const deletedCount = await cleanOldArticles();
        if (deletedCount > 0) {
          console.log(`ğŸ§¹ ì •ë¦¬ ì™„ë£Œ: ${deletedCount}ê°œì˜ ì˜¤ë˜ëœ ê¸°ì‚¬ë¥¼ ì‚­ì œí–ˆìŠµë‹ˆë‹¤.`);
        }
        
        await renderFeeds();
        document.querySelector(`sl-tab[panel="${articleFilter}"]`).active = true;

        const initialHash = window.location.hash;
        if (initialHash.startsWith('#detail/')) {
          const guid = decodeURIComponent(initialHash.substring(8));
          await refreshAllFeeds();
          showDetailView(guid, true);
        } else {
          await renderArticles();
          await refreshAllFeeds();
        }
      } catch (error) {
        console.error("ì•± ì´ˆê¸°í™” ì‹¤íŒ¨:", error);
        document.body.innerHTML = '<div class="p-4 text-red-600">ì•± ì´ˆê¸°í™” ì‹¤íŒ¨. IndexedDBë¥¼ ì§€ì›í•˜ëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.</div>';
      } finally {
        globalLoader.style.opacity = '0';
        setTimeout(() => {
          globalLoader.style.display = 'none';
        }, 300);
      }
    });
  </script>
</body>

</html>